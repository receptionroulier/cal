<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Calendrier 3-4 semaines — bandes multi-jours</title>
<style>
/* =========================
   THEME & LAYOUT
   ========================= */
:root{
  --bg:#121212;
  --card:#1c1f23;
  --border:#555;
  --text:#eaeaea;
  --muted:#999;
  --accent:#00e5ff;
  --gap:6px;
  --days-font:14px;
  --event-font:13px;
  --weeks:3; /* dynamique via JS */
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Arial,sans-serif}
.container{height:100%;display:flex;flex-direction:column;padding:16px;max-width:1400px;margin:0 auto}
header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
h1{margin:0;color:var(--accent);font-size:20px}
.controls{display:flex;align-items:center;gap:8px}
.controls button, .controls select{background:none;border:1px solid transparent;color:var(--accent);padding:6px 10px;border-radius:8px;cursor:pointer}
.controls button:hover, .controls select:hover{background:rgba(0,229,255,0.06);border-color:rgba(0,229,255,0.08)}

/* calendar container */
.calendar{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 8px 26px rgba(0,0,0,0.6);flex:1;display:flex;flex-direction:column;overflow:hidden;position:relative}

/* grid of days */
.grid{
  display:grid;
  grid-template-columns:repeat(7,1fr);
  gap:var(--gap);
  /* rows computed in JS by setting --weeks and using this rule */
  grid-template-rows: repeat(var(--weeks), 1fr);
  width:100%;
  height:100%;
  position:relative; /* for overlay spans */
}

/* each day cell (content) */
.day{
  background:#141619;border-radius:10px;padding:8px;border:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;position:relative;
}
.day .day-header{display:flex;justify-content:space-between;align-items:center;font-size:var(--days-font);margin-bottom:6px}
.day .date{font-weight:700}
.day.past{opacity:0.75;color:#777}
.day.today{border:2px solid var(--accent);box-shadow:0 4px 18px rgba(0,229,255,0.06)}
.day.future{/* keeps default */}

/* events inside a day (single-day events) */
.events{display:flex;flex-direction:column;gap:6px;overflow:hidden}
.event{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;background:rgba(0,0,0,0.25);cursor:pointer;color:var(--text);font-size:var(--event-font);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.event .time{font-weight:700;min-width:48px;font-size:12px}
.event.allDay .time{display:none}
.event.more{color:var(--muted);background:transparent;padding-left:6px}

/* overlay for multi-day spanning bars */
.spans-overlay {
  position:absolute;
  left:12px; /* match calendar padding */
  right:12px;
  top:12px;
  bottom:12px;
  pointer-events:none; /* bars will enable pointer-events when needed */
  z-index:10;
}

/* a spanning bar */
.span-bar{
  position:absolute;
  height:28px;
  border-radius:6px;
  padding:4px 8px;
  display:flex;
  align-items:center;
  gap:8px;
  box-sizing:border-box;
  color:white;
  font-weight:600;
  font-size:13px;
  overflow:hidden;
  white-space:nowrap;
  text-overflow:ellipsis;
  pointer-events:auto; /* allow clicks */
  cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
}

/* calendar colors */
.c-reception{background:#109c53}
.c-smr{background:#5768cb}
/* fallback */
.span-bar.default{background:var(--accent)}

/* small tooltip-like popup basic */
#popup{
  position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#1c1f23;padding:14px;border-radius:10px;color:#fff;z-index:50;display:none;border:3px solid var(--accent);min-width:260px;
}
#popup h3{margin:0 0 8px 0;font-size:16px}
#popup .close{position:absolute;right:10px;top:8px;cursor:pointer;font-weight:bold}

/* responsive: column collapse */
@media(max-width:900px){ .grid{grid-template-columns:repeat(2,1fr)} }
@media(max-width:520px){ .grid{grid-template-columns:repeat(1,1fr)} }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1 id="month-title">Mois</h1>
      <div class="controls">
        <button id="prev-week" aria-label="Semaine précédente">&lt;</button>
        <button id="today-btn">Aujourd'hui</button>
        <button id="next-week" aria-label="Semaine suivante">&gt;</button>
        <label for="weeks-select" style="color:var(--muted);margin-left:8px;">&nbsp;</label>
        <select id="weeks-select" title="Nombre de semaines">
          <option value="3" selected>3 semaines</option>
          <option value="4">4 semaines</option>
        </select>
      </div>
    </header>

    <main class="calendar" role="application" aria-label="Calendrier">
      <div id="grid" class="grid" aria-live="polite"></div>
      <div id="spans" class="spans-overlay" aria-hidden="false"></div>
    </main>
  </div>

  <div id="popup" role="dialog" aria-modal="true">
    <span class="close" onclick="document.getElementById('popup').style.display='none'">&times;</span>
    <h3 id="popup-title"></h3>
    <div id="popup-time"></div>
  </div>

<script>
/* =========================
   Configuration
   ========================= */
const API_KEY = 'AIzaSyDkQkqPoOGf8umYg2dbeTU0THfLlJnCjXo';
const CALENDARS = [
  { id:'receptionroulier@gmail.com', key:'reception', css:'c-reception'},
  { id:'smr.programme@gmail.com', key:'smr', css:'c-smr'}
];

let WEEKS = 3;               // default
let gridStartDate = null;    // monday of previous week (showing past,current,future(s))
let dates = [];              // array of Date objects for grid cells (length = WEEKS*7)
const gridEl = document.getElementById('grid');
const spansEl = document.getElementById('spans');

/* =========================
   Time / Date helpers (LOCAL)
   - fmtDateLocal: YYYY-MM-DD local (no timezone cross-effects)
   - startOfDayLocal: Date at 00:00 local
   ========================= */
function fmtDateLocal(d){
  const dt = (d instanceof Date) ? d : new Date(d);
  return dt.getFullYear() + '-' + String(dt.getMonth()+1).padStart(2,'0') + '-' + String(dt.getDate()).padStart(2,'0');
}
function startOfDayLocal(d){
  const dt = new Date(d);
  dt.setHours(0,0,0,0); dt.setMilliseconds(0);
  return dt;
}
function endOfDayLocal(d){
  const dt = new Date(d);
  dt.setHours(23,59,59,999);
  return dt;
}
function pad(n){ return n<10?'0'+n:n; }
function fmtTime(dt){ if(!dt) return ''; const d=new Date(dt); return pad(d.getHours())+':'+pad(d.getMinutes()); }

/* =========================
   Compute grid start:
   requirement: always show "semaine passée, semaine actuelle, semaine(s) future(s)",
   so gridStartDate = monday of previous week (not the monday of current week).
   We keep the same semantics as you had originally.
   ========================= */
function computeGridStart(referenceDate = new Date()){
  const today = new Date(referenceDate);
  const day = today.getDay(); // 0..6 (Sun..Sat)
  // monday of this week:
  const mondayThisWeek = new Date(today);
  mondayThisWeek.setHours(0,0,0,0);
  mondayThisWeek.setDate(today.getDate() - ((day + 6) % 7));
  // monday previous week:
  const mondayLastWeek = new Date(mondayThisWeek);
  mondayLastWeek.setDate(mondayLastWeek.getDate() - 7);
  return mondayLastWeek;
}

/* =========================
   Build dates array based on gridStartDate and WEEKS
   Also set CSS variable --weeks for row sizing
   ========================= */
function buildDates(){
  dates = [];
  for(let w=0; w<WEEKS; w++){
    for(let d=0; d<7; d++){
      const dt = new Date(gridStartDate);
      dt.setDate(gridStartDate.getDate() + w*7 + d);
      dt.setHours(0,0,0,0);
      dates.push(dt);
    }
  }
  document.documentElement.style.setProperty('--weeks', String(WEEKS));
  return dates;
}

/* =========================
   Fetch events from Google Calendar
   (returns raw items grouped by calendar.key)
   ========================= */
async function fetchEvents(timeMinISO, timeMaxISO){
  const all = [];
  for(const cal of CALENDARS){
    try{
      const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(cal.id)}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMinISO)}&timeMax=${encodeURIComponent(timeMaxISO)}&singleEvents=true&orderBy=startTime&maxResults=2500`;
      const res = await fetch(url);
      if(!res.ok) { console.warn('Calendar fetch failed', cal.id, res.status); all.push({calendar:cal,items:[]}); continue; }
      const json = await res.json();
      all.push({calendar:cal, items: json.items || []});
    }catch(err){
      console.warn('Fetch error', cal.id, err);
      all.push({calendar:cal, items:[]});
    }
  }
  return all;
}

/* =========================
   Process events:
   - normalize start/end to local Date objects
   - treat Google end as exclusive: take endMoment - 1 ms to find last included day
   - return list of normalized events with day-span indices relative to dates[]
   ========================= */
function normalizeEvents(rawResults){
  const normalized = [];

  for(const res of rawResults){
    const cal = res.calendar;
    for(const it of res.items){
      // dedupe lightly (iCalUID preferred)
      const uid = it.iCalUID || it.id || (it.summary || '') + (it.start?.dateTime || it.start?.date || '');
      // compute start/end moments
      const hasDateTime = !!it.start?.dateTime;
      const rawStart = hasDateTime ? new Date(it.start.dateTime) : new Date(it.start.date + 'T00:00:00');
      // Google uses exclusive end for allDay and ranges; convert end to last included millisecond
      const rawEndRaw = hasDateTime ? new Date(it.end.dateTime) : new Date(it.end.date + 'T00:00:00');
      // subtract 1ms to get inclusive end moment
      const rawEnd = new Date(rawEndRaw.getTime() - 1);

      // Determine local day keys
      const startDayKey = fmtDateLocal(rawStart);
      const endDayKey = fmtDateLocal(rawEnd);

      // find startIndex / endIndex in dates[]
      let startIndex = dates.findIndex(d => fmtDateLocal(d) === startDayKey);
      let endIndex = dates.findIndex(d => fmtDateLocal(d) === endDayKey);

      // If event is outside visible range, clamp to visible range
      if(endIndex < 0 || startIndex < 0){
        // might partially intersect — compute indices by comparing moments
        // find first index where date <= rawEnd && date >= rawStart intersection
        const firstInside = dates.findIndex(d => startOfDayLocal(d).getTime() <= rawEnd.getTime() && endOfDayLocal(d).getTime() >= rawStart.getTime());
        if(firstInside === -1) continue; // completely outside
        startIndex = Math.max(0, startIndex === -1 ? firstInside : startIndex);
        // compute lastInside:
        let lastInside = dates.length - 1;
        for(let i=dates.length-1;i>=0;i--){
          const d = dates[i];
          if(startOfDayLocal(d).getTime() <= rawEnd.getTime() && endOfDayLocal(d).getTime() >= rawStart.getTime()){
            lastInside = i; break;
          }
        }
        endIndex = Math.min(dates.length-1, lastInside);
      }

      // normalized event
      normalized.push({
        uid,
        title: it.summary || '(sans titre)',
        startMs: rawStart.getTime(),
        endMs: rawEnd.getTime(),
        startIndex,
        endIndex,
        allDay: !!it.start?.date && !it.start?.dateTime,
        calendarKey: cal.key,
        raw: it
      });
    }
  }

  // sort normalized events by startMs asc
  normalized.sort((a,b)=> a.startMs - b.startMs);
  return normalized;
}

/* =========================
   Render grid cells (days) + overlay spans
   ========================= */
function renderEmptyGrid(){
  gridEl.innerHTML = '';
  // buildDates filled dates[]
  buildDates();
  const dayNames = ['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'];
  for(let i=0;i<dates.length;i++){
    const d = dates[i];
    const cell = document.createElement('div');
    cell.className = 'day';
    cell.dataset.date = fmtDateLocal(d);
    const header = document.createElement('div');
    header.className = 'day-header';
    header.innerHTML = `<div>${dayNames[d.getDay()]}</div><div class="date">${d.getDate()}</div>`;
    cell.appendChild(header);
    const eventsContainer = document.createElement('div');
    eventsContainer.className = 'events';
    cell.appendChild(eventsContainer);
    gridEl.appendChild(cell);
  }
  // clear spans overlay
  spansEl.innerHTML = '';
}

/* =========================
   Place event bars (multi-day) into overlay, and single-day events into cells
   - Bars are absolutely positioned within spansEl.
   - We compute left% & width% based on startIndex/endIndex vs totalDays.
   - To avoid vertical overlap in same week row, we allocate lanes per week.
   ========================= */
function renderEvents(normalized){
  // clear day lists
  document.querySelectorAll('.day .events').forEach(el => el.innerHTML = '');

  // overlay dimension helpers
  const totalDays = dates.length;
  const overlayRect = spansEl.getBoundingClientRect();
  const overlayWidth = overlayRect.width || spansEl.clientWidth || 1;
  const overlayHeight = overlayRect.height || spansEl.clientHeight || 1;
  const rowHeight = overlayHeight / WEEKS;

  // lanes per week to manage stacking
  const lanesPerWeek = Array.from({length:WEEKS}, ()=>[]); // array of arrays of occupied lane widths.

  // process events
  normalized.forEach(ev=>{
    // if event spans more than one cell (multi-day) => create span
    const spanLength = ev.endIndex - ev.startIndex + 1;
    if(spanLength > 1){
      // compute left% / width%
      const leftPct = (ev.startIndex / totalDays) * 100;
      const widthPct = (spanLength / totalDays) * 100;

      // determine row index (week row) based on startIndex
      const rowIndex = Math.floor(ev.startIndex / 7);

      // find first free lane in this week where it won't overlap (simple lane packing)
      let lane = 0;
      const lanes = lanesPerWeek[rowIndex];
      while(true){
        let conflict = false;
        for(const placed of lanes[lane] || []){
          // placed: {startIndex,endIndex}
          if(!(ev.endIndex < placed.startIndex || ev.startIndex > placed.endIndex)){
            conflict = true; break;
          }
        }
        if(!conflict) break;
        lane++;
      }
      // ensure lanes[rowIndex][lane] exists
      lanes[rowIndex][lane] = lanes[rowIndex][lane] || [];
      lanes[rowIndex][lane].push({startIndex:ev.startIndex, endIndex:ev.endIndex});

      // compute top (px)
      const topPx = rowIndex * rowHeight + lane * 32 + 4; // 32px lane height + small gap
      const barHeight = 28; // px

      const bar = document.createElement('div');
      bar.className = 'span-bar';
      // apply calendar color class
      const calMeta = CALENDARS.find(c=>c.key === ev.calendarKey);
      if(calMeta) bar.classList.add(calMeta.css);
      else bar.classList.add('default');

      // style absolute
      bar.style.left = leftPct + '%';
      bar.style.width = widthPct + '%';
      bar.style.top = topPx + 'px';
      bar.style.height = barHeight + 'px';
      bar.title = `${ev.title} — ${new Date(ev.startMs).toLocaleString()} → ${new Date(ev.endMs).toLocaleString()}`;

      // content: show title (wrap if needed)
      const t = document.createElement('div');
      t.style.color = '#fff';
      t.style.fontWeight = '600';
      t.style.overflow = 'hidden';
      t.style.textOverflow = 'ellipsis';
      t.style.whiteSpace = 'nowrap';
      t.textContent = ev.title;
      bar.appendChild(t);

      // pointer: show popup on click
      bar.addEventListener('click', (e)=>{
        e.stopPropagation();
        showPopup(ev.title, new Date(ev.startMs).toLocaleString(), new Date(ev.endMs).toLocaleString(), ev.allDay, calMeta?.css);
      });

      spansEl.appendChild(bar);
    } else {
      // single-day (or stays within same day): push into the day's list
      const idx = ev.startIndex;
      if(idx >=0 && idx < dates.length){
        const dayCell = gridEl.children[idx];
        if(dayCell){
          const container = dayCell.querySelector('.events');
          const evEl = document.createElement('div');
          evEl.className = 'event' + (ev.allDay ? ' allDay' : '');
          const calMeta = CALENDARS.find(c=>c.key===ev.calendarKey);
          if(calMeta) evEl.classList.add(calMeta.css); // color class applies to text? we want background; better keep neutral
          evEl.innerHTML = `<div class="time">${ev.allDay ? '' : fmtTime(ev.startMs)}</div><div class="title">${ev.title}</div>`;
          evEl.title = `${ev.title}\n${new Date(ev.startMs).toLocaleString()} → ${new Date(ev.endMs).toLocaleString()}`;
          evEl.addEventListener('click',(e)=>{ e.stopPropagation(); showPopup(ev.title, new Date(ev.startMs).toLocaleString(), new Date(ev.endMs).toLocaleString(), ev.allDay, calMeta?.css);});
          container.appendChild(evEl);
        }
      }
    }
  });
}

/* =========================
   Main flow: build grid, fetch events, normalize and render
   ========================= */
async function refreshCalendar(){
  // build empty grid (dates and day cells)
  renderEmptyGrid();

  // compute time range to fetch
  const timeMin = startOfDayLocal(dates[0]).toISOString();
  const timeMax = endOfDayLocal(dates[dates.length - 1]).toISOString();

  // fetch events
  const raw = await fetchEvents(timeMin, timeMax);

  // normalize (compute indices)
  const normalized = normalizeEvents(raw);

  // render: days lists + spanning bars
  renderEvents(normalized);

  // update month title (use first visible date)
  const monthNames = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
  const firstDate = dates[0];
  document.getElementById('month-title').textContent = `${monthNames[firstDate.getMonth()]} ${firstDate.getFullYear()}`;
}

/* =========================
   UI helpers & navigation
   ========================= */
function showPopup(title, startStr, endStr, isAllDay, cssClass){
  const pop = document.getElementById('popup');
  document.getElementById('popup-title').textContent = title;
  document.getElementById('popup-time').textContent = isAllDay ? 'Toute la journée' : `${startStr} → ${endStr}`;
  pop.style.borderColor = cssClass === 'c-reception' ? '#109c53' : (cssClass === 'c-smr' ? '#5768cb' : 'var(--accent)');
  pop.style.display = 'block';
}

/* close popup on outside click */
window.addEventListener('click', (e)=>{
  const pop = document.getElementById('popup');
  if(pop.style.display === 'block' && !pop.contains(e.target)) pop.style.display = 'none';
});

/* navigation bindings */
document.getElementById('prev-week').addEventListener('click', ()=>{
  gridStartDate.setDate(gridStartDate.getDate() - 7);
  refreshCalendar();
});
document.getElementById('next-week').addEventListener('click', ()=>{
  gridStartDate.setDate(gridStartDate.getDate() + 7);
  refreshCalendar();
});
document.getElementById('today-btn').addEventListener('click', ()=>{
  gridStartDate = computeGridStart(new Date());
  refreshCalendar();
});
document.getElementById('weeks-select').addEventListener('change', (e)=>{
  WEEKS = parseInt(e.target.value,10);
  // keep same semantic: start at monday previous week relative to today
  gridStartDate = computeGridStart(new Date());
  refreshCalendar();
});

/* handle window resize: re-render spans for proper positioning */
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{ refreshCalendar(); }, 150);
});

/* =========================
   Init
   ========================= */
gridStartDate = computeGridStart(new Date()); // monday of previous week
buildDates(); // populate dates initially so renderEmptyGrid / refreshCalendar can use it
refreshCalendar();
setInterval(refreshCalendar, 60_000); // periodic refresh
</script>
</body>
</html>
