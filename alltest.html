<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ponts HAROPA – Monitoring + Calendrier</title>
<style>
/* =====================
   GLOBAL
===================== */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #101010;
    color: #eaeaea;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

/* =====================
   COLONNE GAUCHE
===================== */
.left {
    flex: 0 0 20%;
    border-right: 1px solid #444;
    padding: 14px;
    overflow-y: auto;
    box-sizing: border-box;
}
.left h2 { color: #00e5ff; text-align: center; }

/* =====================
   CARTES PONTS
===================== */
.pont-card {
    background: #1f1f1f;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 0 5px rgba(0,0,0,0.4);
    border-left: 4px solid #444;
    transition: transform 0.15s ease, box-shadow 0.3s ease;
    margin-bottom: 8px;
}
.pont-card:hover { transform: scale(1.02); }

.pont-card.ferme { border-left-color: #ff4040; }
.pont-card.fermeture { border-left-color: orange; animation: pulse-orange 1.2s infinite; }
.pont-card.manoeuvre { border-left-color: #1c3cff; animation: pulse-blue 1.2s infinite; }
.pont-card.ouvert { border-left-color: #58ff58; }

.pastille { width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; display: inline-block; }
.ferme .pastille      { background: #ff4040; }
.fermeture .pastille  { background: orange; }
.manoeuvre .pastille  { background: #1c3cff; }
.ouvert .pastille     { background: #58ff58; }

.pont-nom { font-weight: bold; display: flex; align-items: center; }

/* =====================
   CALENDRIER
===================== */
.right { flex:1; display:flex; flex-direction:column; height:100%; overflow:hidden; }
#calendar-header { flex:0 0 auto; padding:12px; text-align:center; font-size:22px; color:#00e5ff; border-bottom:1px solid #333; display:flex; justify-content:center; align-items:center; gap:18px; }
.nav-btn { cursor:pointer; color:#00e5ff; font-size:26px; padding:4px 10px; border-radius:6px; transition:0.2s; }
.nav-btn:hover { background:#222; }
.view-btn { cursor:pointer; font-size:14px; padding:4px 10px; background:#222; border-radius:6px; border:1px solid #333; color:#00e5ff; }
.view-btn:hover { background:#333; }

#calendar-grid { flex:1 1 auto; display:grid; gap:1px; background:#333; overflow:auto; box-sizing:border-box; padding:6px; }

/* chaque case relative pour positionnement absolu des bandes */
.calendar-cell {
    background:#1a1a1a;
    padding:6px;
    border:1px solid #222;
    overflow:visible;
    position:relative;
    min-height:70px;
    box-sizing:border-box;
}
.date-label { font-size:12px; font-weight:normal; margin-bottom:4px; color:#ffffff; }

/* événements ponctuels (au-dessus des bandes) */
.event {
    position:relative;
    z-index: 3; /* au-dessus des bandes multi-jours */
    padding:3px 5px;
    border-radius:4px;
    font-size:12px;
    margin-bottom:4px;
    background: rgba(255,255,255,0.03);
}

/* =====================
   BANDES MULTI-JOURS (Option B : bande fine en haut)
   Elles sont affichées en dessous des événements (z-index:1)
===================== */
.multi-band {
  position:absolute;
  height: 14px;
  border-radius:4px;
  padding:0 6px;
  font-size:12px;
  line-height:14px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  box-sizing:border-box;
  top:0;
  z-index: 1; /* dessous */
  left:6px;
  right:6px;
}

/* couleurs par calendrier (plein) */
.multi-band.reception { background: #109c53; color: #ffffff; }
.multi-band.navire    { background: #3644b3; color: #ffffff; }

/* small mid bar style */
.multi-mid {
  height: 8px;
  top:3px;
  border-radius:3px;
  opacity:0.95;
}

/* =====================
   ANIMATIONS
===================== */
@keyframes pulse-blue {0%,100% { box-shadow: 0 0 5px rgba(28,60,255,0.4); transform: scale(1);}50% { box-shadow: 0 0 20px rgba(28,60,255,0.7); transform: scale(1.02);} }
@keyframes pulse-orange {0%,100% { box-shadow: 0 0 5px rgba(255,165,0,0.4); transform: scale(1);}50% { box-shadow: 0 0 20px rgba(255,165,0,0.7); transform: scale(1.02);} }

@media (max-width:900px){
  .left { flex:0 0 30%; }
  .calendar-cell { min-height:90px; }
}
</style>
</head>
<body>

<div class="left">
    <h2>État des Ponts</h2>
    <div id="ponts-table">Chargement…</div>
</div>

<div class="right">
    <div id="calendar-header">
        <span class="nav-btn" id="prev-btn">‹</span>
        <span id="calendar-title">Chargement…</span>
        <span class="nav-btn" id="next-btn">›</span>
        <span class="view-btn" id="view-3w">3 semaines</span>
        <span class="view-btn" id="view-4w">4 semaines</span>
        <span class="nav-btn" id="today-btn" style="font-size:18px;">Aujourd’hui</span>
    </div>
    <div id="calendar-grid"></div>
</div>

<script>
/* ============================================================
   CONFIGURATION CALENDRIER + PONTS (toujours conservés)
============================================================ */

/* CALENDAR */
const API_KEY = "AIzaSyDkQkqPoOGf8umYg2dbeTU0THfLlJnCjXo";
const CAL_RECEPTION = "receptionroulier@gmail.com";
const CAL_NAVIRE = "smr.programme@gmail.com";

let viewDays = 21; // par défaut 3 semaines
let offsetWeeks = 0;

const CAL_HASH_KEY = "calendarHash";
const CAL_CACHE_KEY = "calendarCache";
const CAL_REFRESH_INTERVAL = 60000; // 1 min

/* PONTS - inchangés */
const CACHE_KEY_DATA="pontsData";
const CACHE_KEY_HASH="pontsHash";
const CACHE_KEY_TIME="pontsCacheTime";
const CACHE_EXPIRATION=60000;
const REFRESH_INTERVAL=10000;

const PROXIES=[
    "https://api.allorigins.win/get?url=",
    "https://cors-anywhere.herokuapp.com/",
    "https://thingproxy.freeboard.io/fetch/"
];

/* =====================
   UTIL DATES
===================== */
function getStartMonday(date){
    const d = new Date(date);
    const day = d.getDay();
    const diff = (day === 0 ? -6 : 1) - day;
    d.setDate(d.getDate() + diff);
    return d;
}
function addDays(date,n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function formatDate(d){ return d.toISOString().split("T")[0]; }
function formatMonthRange(start,end){
    const m=["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
    const m1=m[start.getMonth()], m2=m[end.getMonth()];
    const y1=start.getFullYear(), y2=end.getFullYear();
    return (m1===m2 && y1===y2)?`${m1} ${y1}`:`${m1} — ${m2} ${y2}`;
}
function dayName(d){ return ["Dim","Lun","Mar","Mer","Jeu","Ven","Sam"][d.getDay()]; }

/* =====================
   HASH UTIL
===================== */
async function hashObject(obj){
    const txt = JSON.stringify(obj);
    const data = new TextEncoder().encode(txt);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,"0")).join("");
}

/* =====================
   FETCH CALENDARS (avec hash/cache)
===================== */
async function fetchCalendarWithHash(start, end){
    const timeMin = start.toISOString();
    const timeMax = addDays(end,1).toISOString();

    const urlRec = `https://www.googleapis.com/calendar/v3/calendars/${CAL_RECEPTION}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;
    const urlNav = `https://www.googleapis.com/calendar/v3/calendars/${CAL_NAVIRE}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;

    const [recRaw, navRaw] = await Promise.all([
        fetch(urlRec).then(r=>r.json()).catch(()=>({items:[]})),
        fetch(urlNav).then(r=>r.json()).catch(()=>({items:[]})),
    ]);

    const events = { reception: recRaw.items || [], navire: navRaw.items || [] };

    const newHash = await hashObject(events);
    const oldHash = localStorage.getItem(CAL_HASH_KEY);

    if(newHash === oldHash && localStorage.getItem(CAL_CACHE_KEY)){
        try { return JSON.parse(localStorage.getItem(CAL_CACHE_KEY)); } catch {}
    }

    localStorage.setItem(CAL_HASH_KEY,newHash);
    localStorage.setItem(CAL_CACHE_KEY,JSON.stringify(events));
    return events;
}

/* ============================================================
   NORMALISATION (corrige décalage all-day)
   -> retourne 'YYYY-MM-DD' strings
============================================================ */
function getLocalDateFromGoogleEventStart(ev){
    if(ev.start?.date){
        // all-day: already a local YYYY-MM-DD
        return ev.start.date;
    }
    if(ev.start?.dateTime){
        const d = new Date(ev.start.dateTime);
        // convert to local date in ISO yyyy-mm-dd
        const local = new Date(d.getTime() - d.getTimezoneOffset()*60000);
        return local.toISOString().split('T')[0];
    }
    return null;
}
function getLocalDateFromGoogleEventEnd(ev){
    if(ev.end?.date){
        // Google end.date is exclusive for all-day events: subtract 1 day to get last included day
        const d = new Date(ev.end.date);
        d.setDate(d.getDate() - 1);
        return d.toISOString().split('T')[0];
    }
    if(ev.end?.dateTime){
        const d = new Date(ev.end.dateTime);
        const local = new Date(d.getTime() - d.getTimezoneOffset()*60000);
        return local.toISOString().split('T')[0];
    }
    return null;
}

/* ============================================================
   GRID CREATION
============================================================ */
function createGrid(start, viewDays){
    const grid = document.getElementById('calendar-grid');
    const rows = (viewDays===21)?3:4;
    grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    grid.style.gridTemplateColumns = `repeat(7, 1fr)`;
    grid.innerHTML = '';
    for(let i=0;i<viewDays;i++){
        const d = addDays(start,i);
        const cell = document.createElement('div');
        cell.className = 'calendar-cell';
        cell.dataset.date = formatDate(d);
        cell.dataset.index = i;
        cell.innerHTML = `<div class="date-label">${dayName(d)} ${d.getDate()}</div>`;
        grid.appendChild(cell);
    }
}

/* ============================================================
   ALLOCATION NIVEAUX (anticollision)
============================================================ */
function allocateLevel(occupied, dayIndexes){
    let level = 0;
    while(true){
        let ok = true;
        for(const di of dayIndexes){
            const row = occupied[di] || [];
            if(row[level]) { ok = false; break; }
        }
        if(ok){
            for(const di of dayIndexes){
                occupied[di] = occupied[di] || [];
                occupied[di][level] = true;
            }
            return level;
        }
        level++;
    }
}

/* ============================================================
   RENDERING: multi-day bands then single-day events (so bands are under)
============================================================ */
function renderMultiDayBands(allEvents, start, viewDays){
    const cells = Array.from(document.querySelectorAll('.calendar-cell'));
    const dateToIndex = {};
    cells.forEach(c => dateToIndex[c.dataset.date] = parseInt(c.dataset.index,10));
    const occupied = {};

    // collect multi-day events
    const multi = [];
    ['reception','navire'].forEach(type=>{
        (allEvents[type]||[]).forEach(it=>{
            const sStr = getLocalDateFromGoogleEventStart(it);
            const eStr = getLocalDateFromGoogleEventEnd(it);
            if(!sStr || !eStr) return;
            const sDate = new Date(sStr + 'T00:00:00');
            const eDate = new Date(eStr + 'T00:00:00');
            const span = Math.round((eDate - sDate)/86400000) + 1;
            if(span >= 2){
                multi.push({ type, original: it, summary: it.summary || '(Sans titre)', sDate, eDate, sStr, eStr });
            }
        });
    });

    multi.forEach(ev=>{
        const dayIndexes = [];
        for(let d = new Date(ev.sDate); d <= ev.eDate; d = addDays(d,1)){
            const key = formatDate(d);
            if(key in dateToIndex) dayIndexes.push(dateToIndex[key]);
        }
        if(dayIndexes.length === 0) return;
        const level = allocateLevel(occupied, dayIndexes);

        dayIndexes.forEach((di, idx) => {
            const cell = document.querySelector(`.calendar-cell[data-index="${di}"]`);
            if(!cell) return;

            const top = 18 + level * 20; // spacing under date label
            const band = document.createElement('div');
            band.className = `multi-band ${ev.type}`;
            band.style.top = top + 'px';
            // content
            if(idx === 0){
                // show start time if time present + title
                let tstr = '';
                if(ev.original.start?.dateTime){
                    const d = new Date(ev.original.start.dateTime);
                    tstr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0') + ' ';
                }
                band.textContent = tstr + ev.summary;
                band.title = ev.summary + ' — début: ' + ev.sDate.toLocaleString();
            } else if(idx === dayIndexes.length - 1){
                // show end time aligned right (preceded by '>')
                let tend = '';
                if(ev.original.end?.dateTime){
                    const d = new Date(ev.original.end.dateTime);
                    tend = '>' + d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0');
                }
                band.textContent = tend;
                band.title = ev.summary + ' — fin: ' + ev.eDate.toLocaleString();
            } else {
                // middle segment: make smaller height for visual continuity
                band.classList.add('multi-mid');
                band.style.height = '8px';
                band.style.top = (top + 3) + 'px';
                band.textContent = '';
            }

            cell.appendChild(band);
        });
    });
}

function renderSingleDayEvents(allEvents){
    ['reception','navire'].forEach(type=>{
        (allEvents[type] || []).forEach(it=>{
            // determine start/end local day strings
            const sStr = getLocalDateFromGoogleEventStart(it);
            const eStr = getLocalDateFromGoogleEventEnd(it);
            if(!sStr || !eStr) return;
            const sDate = new Date(sStr + 'T00:00:00');
            const eDate = new Date(eStr + 'T00:00:00');
            const span = Math.round((eDate - sDate)/86400000) + 1;

            if(span === 1){
                const cell = document.querySelector(`.calendar-cell[data-date="${sStr}"]`);
                if(!cell) return;
                const div = document.createElement('div');
                div.className = 'event ' + type;
                // time if dateTime
                let timeStr = '';
                if(it.start?.dateTime){
                    const d = new Date(it.start.dateTime);
                    timeStr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0') + ' ';
                }
                div.innerHTML = `${timeStr}${it.summary || '(Sans titre)'}`;
                cell.appendChild(div);
            }
        });
    });
}

/* ============================================================
   MAIN LOAD: build grid, fetch events, render bands then events
============================================================ */
async function loadCalendar(){
    const today = new Date();
    const mondayCurrent = getStartMonday(today);
    const start = new Date(mondayCurrent);
    start.setDate(start.getDate() - 7 + offsetWeeks*7);
    const end = addDays(start, viewDays - 1);
    document.getElementById('calendar-title').textContent = formatMonthRange(start, end);

    createGrid(start, viewDays);

    try {
        const events = await fetchCalendarWithHash(start, end);

        // first draw multi-day bands (under)
        renderMultiDayBands(events, start, viewDays);

        // then draw single-day events (above)
        renderSingleDayEvents(events);

    } catch(err){
        console.error('Erreur loadCalendar:', err);
    }
}

/* =====================
   NAVIGATION
===================== */
document.getElementById("prev-btn").onclick = ()=>{ offsetWeeks -= 1; loadCalendar(); };
document.getElementById("next-btn").onclick = ()=>{ offsetWeeks += 1; loadCalendar(); };
document.getElementById("today-btn").onclick = ()=>{ offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-3w").onclick = ()=>{ viewDays = 21; offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-4w").onclick = ()=>{ viewDays = 28; offsetWeeks = 0; loadCalendar(); };

loadCalendar();
setInterval(loadCalendar, CAL_REFRESH_INTERVAL);

/* ============================================================
   PONTS HAROPA (inchangée : repris mot pour mot et conservée)
============================================================ */
async function sha256(str){
    const data=new TextEncoder().encode(str);
    const digest=await crypto.subtle.digest("SHA-256",data);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function fetchWithRandomProxy(url) {
    const shuffled = [...PROXIES].sort(() => Math.random() - 0.5);
    for (const proxy of shuffled) {
        try {
            const fullUrl = proxy + encodeURIComponent(url);
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);
            const res = await fetch(fullUrl, { signal: controller.signal });
            clearTimeout(timeout);
            if (!res.ok) throw new Error(`Proxy failed: ${res.status}`);
            let txt = await res.text();
            try { const parsed = JSON.parse(txt); if (parsed.contents) return parsed.contents; } catch {}
            return txt;
        }
        catch(err){
            console.warn(`Proxy ${proxy} échoué : ${err.message}`);
        }
    }
    throw new Error("Tous les proxys ont échoué");
}
async function checkAndUpdate(){
    const now = Date.now();
    const last = localStorage.getItem(CACHE_KEY_TIME);
    if (last && now-last < CACHE_EXPIRATION){
        const cached = localStorage.getItem(CACHE_KEY_DATA);
        if (cached){ renderPonts(JSON.parse(cached)); return; }
    }
    await fetchWithHashControl();
}
async function fetchWithHashControl(){
    try{
        const rawContent = await fetchWithRandomProxy("https://www.havre-port.com/map/getPonts");
        const newHash = await sha256(rawContent);
        const oldHash = localStorage.getItem(CACHE_KEY_HASH);
        if (newHash === oldHash && localStorage.getItem(CACHE_KEY_DATA)){
            renderPonts(JSON.parse(localStorage.getItem(CACHE_KEY_DATA)));
            return;
        }
        const ponts = Object.values(JSON.parse(rawContent).data);
        const unique = Array.from(new Map(ponts.map(p=>[p.nom,p])).values());
        const ordered = unique.sort((a,b)=>{
            const score=p=>{
                const s=p.statutText.toLowerCase();
                if(s.includes("fermeture")) return 1;
                if(s.includes("fermé")) return 2;
                if(s.includes("manoeuvre")) return 3;
                if(s.includes("ouvert")) return 4;
                return 5;
            };
            return score(a)-score(b);
        });
        localStorage.setItem(CACHE_KEY_DATA,JSON.stringify(ordered));
        localStorage.setItem(CACHE_KEY_HASH,newHash);
        localStorage.setItem(CACHE_KEY_TIME,Date.now());
        renderPonts(ordered);
    }
    catch(err){
        console.error("Erreur récupération ponts:",err);
        document.getElementById("ponts-table").textContent="Impossible de récupérer les ponts.";
    }
}
function renderPonts(list){
    const container=document.getElementById("ponts-table");
    container.innerHTML=list.map(p=>{
        const s=p.statutText.toLowerCase();
        const cls =
            s.includes("fermeture") ? "fermeture" :
            s.includes("fermé")      ? "ferme" :
            s.includes("manoeuvre")  ? "manoeuvre" :
            s.includes("ouvert")     ? "ouvert" : "ferme";
        const info = p.forceText || `MàJ : ${p.date}`;
        return `
            <div class="pont-card ${cls}">
                <div class="pont-nom"><span class="pastille"></span>${p.nom}</div>
                <div class="pont-etat">${p.statutText}</div>
                <div class="pont-infos">${info}</div>
            </div>`;
    }).join("");
}
checkAndUpdate();
setInterval(checkAndUpdate,REFRESH_INTERVAL);
</script>
</body>
</html>
