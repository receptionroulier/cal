<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ponts HAROPA – Monitoring + Calendrier</title>
<style>
/* =====================
   GLOBAL
===================== */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #101010;
    color: #eaeaea;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

/* =====================
   COLONNE GAUCHE
===================== */
.left {
    flex: 0 0 20%;
    border-right: 1px solid #444;
    padding: 14px;
    overflow-y: auto;
    box-sizing: border-box;
}
.left h2 { color: #00e5ff; text-align: center; }

/* =====================
   CARTES PONTS
===================== */
.pont-card {
    background: #1f1f1f;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 0 5px rgba(0,0,0,0.4);
    border-left: 4px solid #444;
    transition: transform 0.15s ease, box-shadow 0.3s ease;
    margin-bottom: 8px;
}
.pont-card:hover { transform: scale(1.02); }

.pont-card.ferme { border-left-color: #ff4040; }
.pont-card.fermeture { border-left-color: orange; animation: pulse-orange 1.2s infinite; }
.pont-card.manoeuvre { border-left-color: #1c3cff; animation: pulse-blue 1.2s infinite; }
.pont-card.ouvert { border-left-color: #58ff58; }

.pastille { width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; display: inline-block; }
.ferme .pastille      { background: #ff4040; }
.fermeture .pastille  { background: orange; }
.manoeuvre .pastille  { background: #1c3cff; }
.ouvert .pastille     { background: #58ff58; }

.pont-nom { font-weight: bold; display: flex; align-items: center; }

/* =====================
   CALENDRIER
===================== */
.right { flex:1; display:flex; flex-direction:column; height:100%; overflow:hidden; }
#calendar-header { flex:0 0 auto; padding:12px; text-align:center; font-size:22px; color:#00e5ff; border-bottom:1px solid #333; display:flex; justify-content:center; align-items:center; gap:18px; }
.nav-btn { cursor:pointer; color:#00e5ff; font-size:26px; padding:4px 10px; border-radius:6px; transition:0.2s; }
.nav-btn:hover { background:#222; }
.view-btn { cursor:pointer; font-size:14px; padding:4px 10px; background:#222; border-radius:6px; border:1px solid #333; color:#00e5ff; }
.view-btn:hover { background:#333; }

#calendar-grid { flex:1 1 auto; display:grid; gap:1px; background:#333; overflow:auto; box-sizing:border-box; padding:6px; }

/* chaque case relative pour positionnement absolu des bandes */
.calendar-cell {
    background:#1a1a1a;
    padding:6px;
    border:1px solid #222;
    overflow:visible;
    position:relative;
    min-height:70px;
    box-sizing:border-box;
}
.date-label { font-size:12px; font-weight:normal; margin-bottom:4px; color:#ffffff; }

/* événements ponctuels (au-dessus des bandes) */
.event {
    position:relative;
    z-index: 3; /* au-dessus des bandes multi-jours */
    padding:3px 5px;
    border-radius:4px;
    font-size:12px;
    margin-bottom:4px;
    background: rgba(255,255,255,0.03);
}

/* =====================
   BANDES MULTI-JOURS (Option B : bande fine en haut)
   Elles sont affichées en dessous des événements (z-index:1)
===================== */
.multi-row {
  position:relative;
  height: 20px; /* hauteur par niveau */
}
.multi-band {
  position:absolute;
  height: 14px;
  border-radius:4px;
  padding:0 6px;
  font-size:12px;
  line-height:14px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  box-sizing:border-box;
  top:2px;
  z-index: 1; /* en dessous des .event */
}

/* couleurs par calendrier (plein) */
.multi-band.reception { background: #109c53; color: #ffffff; }
.multi-band.navire    { background: #3644b3; color: #ffffff; }

/* styles pour texte début / fin */
.multi-start { text-align:left; }
.multi-end   { text-align:right; }

/* mid-segment small bar (visuel continuité) */
.multi-mid {
  height: 8px;
  top:3px;
  border-radius:3px;
  opacity:0.95;
}

/* =====================
   ANIMATIONS
===================== */
@keyframes pulse-blue {0%,100% { box-shadow: 0 0 5px rgba(28,60,255,0.4); transform: scale(1);}50% { box-shadow: 0 0 20px rgba(28,60,255,0.7); transform: scale(1.02);} }
@keyframes pulse-orange {0%,100% { box-shadow: 0 0 5px rgba(255,165,0,0.4); transform: scale(1);}50% { box-shadow: 0 0 20px rgba(255,165,0,0.7); transform: scale(1.02);} }

@media (max-width:900px){
  .left { flex:0 0 30%; }
  .calendar-cell { min-height:90px; }
}
</style>
</head>
<body>

<div class="left">
    <h2>État des Ponts</h2>
    <div id="ponts-table">Chargement…</div>
</div>

<div class="right">
    <div id="calendar-header">
        <span class="nav-btn" id="prev-btn">‹</span>
        <span id="calendar-title">Chargement…</span>
        <span class="nav-btn" id="next-btn">›</span>
        <span class="view-btn" id="view-3w">3 semaines</span>
        <span class="view-btn" id="view-4w">4 semaines</span>
        <span class="nav-btn" id="today-btn" style="font-size:18px;">Aujourd’hui</span>
    </div>
    <div id="calendar-grid"></div>
</div>

<script>
/* ============================================================
   CONFIGURATION CALENDRIER
   (Conserve ta logique ponts telle quelle, modifs uniquement calendrier)
============================================================ */
const API_KEY = "AIzaSyDkQkqPoOGf8umYg2dbeTU0THfLlJnCjXo";
const CAL_RECEPTION = "receptionroulier@gmail.com";
const CAL_NAVIRE = "smr.programme@gmail.com";

let viewDays = 21; // par défaut 3 semaines
let offsetWeeks = 0; // décalage par rapport à la semaine actuelle

/* cache/hash calendrier */
const CAL_HASH_KEY = "calendarHash";
const CAL_CACHE_KEY = "calendarCache";
const CAL_REFRESH_INTERVAL = 60000; // 1min

/* ============================================================
   UTILITAIRES DATES
============================================================ */
function getStartMonday(date){
    const d = new Date(date);
    const day = d.getDay();
    const diff = (day === 0 ? -6 : 1) - day;
    d.setDate(d.getDate() + diff);
    return d;
}
function addDays(date,n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function formatDate(d){ return d.toISOString().split("T")[0]; }
function formatMonthRange(start,end){
    const m=["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
    const m1=m[start.getMonth()], m2=m[end.getMonth()];
    const y1=start.getFullYear(), y2=end.getFullYear();
    return (m1===m2 && y1===y2)?`${m1} ${y1}`:`${m1} — ${m2} ${y2}`;
}
function dayName(d){ return ["Dim","Lun","Mar","Mer","Jeu","Ven","Sam"][d.getDay()]; }

/* ============================================================
   HASH + FETCH CALENDAR
============================================================ */
async function hashObject(obj){
    const txt = JSON.stringify(obj);
    const data = new TextEncoder().encode(txt);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,"0")).join("");
}

async function fetchCalendarWithHash(start, end){
    const timeMin = start.toISOString();
    const timeMax = addDays(end,1).toISOString();

    const urlRec = `https://www.googleapis.com/calendar/v3/calendars/${CAL_RECEPTION}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;
    const urlNav = `https://www.googleapis.com/calendar/v3/calendars/${CAL_NAVIRE}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;

    const [recRaw, navRaw] = await Promise.all([
        fetch(urlRec).then(r=>r.json()).catch(()=>({items:[]})),
        fetch(urlNav).then(r=>r.json()).catch(()=>({items:[]})),
    ]);

    const events = { reception: recRaw.items || [], navire: navRaw.items || [] };

    const newHash = await hashObject(events);
    const oldHash = localStorage.getItem(CAL_HASH_KEY);

    if(newHash === oldHash && localStorage.getItem(CAL_CACHE_KEY)){
        try { return JSON.parse(localStorage.getItem(CAL_CACHE_KEY)); } catch {}
    }

    localStorage.setItem(CAL_HASH_KEY,newHash);
    localStorage.setItem(CAL_CACHE_KEY,JSON.stringify(events));
    return events;
}

/* ============================================================
   NORMALISATION DES DATES (corrige décalage all-day)
   getLocalDateFromGoogleEventStart/End retournent 'YYYY-MM-DD'
   start = inclusive, end = inclusive (ajusté pour all-day)
============================================================ */
function getLocalDateFromGoogleEventStart(ev){
    if(ev.start?.date){
        // all-day: treat as local date (already YYYY-MM-DD)
        return ev.start.date;
    }
    if(ev.start?.dateTime){
        const d = new Date(ev.start.dateTime);
        // convert to local date string
        return d.toISOString().split("T")[0];
    }
    return null;
}
function getLocalDateFromGoogleEventEnd(ev){
    if(ev.end?.date){
        // Google gives end.date as exclusive for all-day: subtract one day to get inclusive last day
        const d = new Date(ev.end.date);
        d.setDate(d.getDate()-1);
        return d.toISOString().split("T")[0];
    }
    if(ev.end?.dateTime){
        const d = new Date(ev.end.dateTime);
        return d.toISOString().split("T")[0];
    }
    return null;
}

/* ============================================================
   GRID CREATION
============================================================ */
function createGrid(start, viewDays){
    const grid = document.getElementById("calendar-grid");
    const rows = (viewDays === 21)?3:4;
    grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    grid.style.gridTemplateColumns = `repeat(7, 1fr)`;
    grid.innerHTML = "";
    const dates = [];
    for(let i=0;i<viewDays;i++){
        const d = addDays(start,i);
        const cell = document.createElement("div");
        cell.className = "calendar-cell";
        cell.dataset.date = formatDate(d);
        cell.dataset.index = i;
        // reserve a top area for bands (multiple levels); we'll position via absolute
        cell.innerHTML = `<div class="date-label">${dayName(d)} ${d.getDate()}</div>`;
        grid.appendChild(cell);
        dates.push(formatDate(d));
    }
    return dates;
}

/* ============================================================
   ALLOCATION DE NIVEAUX (anticollision)
   occupied[dayIndex] = [bool,bool,...] indiquant niveaux pris
============================================================ */
function allocateLevel(occupied, dayIndexes){
    let level = 0;
    while(true){
        let ok = true;
        for(const di of dayIndexes){
            const row = occupied[di] || [];
            if(row[level]) { ok = false; break; }
        }
        if(ok){
            for(const di of dayIndexes){
                occupied[di] = occupied[di] || [];
                occupied[di][level] = true;
            }
            return level;
        }
        level++;
    }
}

/* ============================================================
   LAYOUT & RENDER des événements
   - Les événements ponctuels (single-day) gardent le rendu .event (au-dessus)
   - Les multi-jours deviennent des bandes (.multi-band) et sont en dessous (z-index)
============================================================ */
function clearPreviousEventLayers(){
    // remove any previous multi-band / event elements inside cells
    document.querySelectorAll('.calendar-cell').forEach(cell=>{
        // keep date-label but remove other children
        const labels = cell.querySelectorAll('.date-label');
        cell.innerHTML = '';
        labels.forEach(l=>cell.appendChild(l));
    });
}

function renderSingleDayEvents(flatEvents){
    // flatEvents: array of events that fully fall in a single day in view
    flatEvents.forEach(ev=>{
        const dateKey = ev.startDateStr;
        const cell = document.querySelector(`.calendar-cell[data-date="${dateKey}"]`);
        if(!cell) return;
        const div = document.createElement('div');
        div.className = 'event ' + ev.type;
        // time if dateTime
        let timeStr = '';
        if(ev.start.dateTime){
            const d = new Date(ev.start.dateTime);
            timeStr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0') + ' ';
        }
        div.innerHTML = `${timeStr}${ev.summary || '(Sans titre)'}`;
        cell.appendChild(div);
    });
}

function renderMultiDayBands(allEvents, start, viewDays){
    // prepare date -> index map
    const cells = Array.from(document.querySelectorAll('.calendar-cell'));
    const dateToIndex = {};
    cells.forEach(c => dateToIndex[c.dataset.date] = parseInt(c.dataset.index,10));
    const occupied = {}; // per day index array of booleans per level

    // build list of multi-day events
    const multiEvents = [];

    // items are in allEvents.reception / navire
    ['reception','navire'].forEach(type=>{
        (allEvents[type]||[]).forEach(it=>{
            // normalize start/end inclusive
            const sStr = getLocalDateFromGoogleEventStart(it);
            const eStr = getLocalDateFromGoogleEventEnd(it);
            if(!sStr || !eStr) return;
            const sDate = new Date(sStr + 'T00:00:00');
            const eDate = new Date(eStr + 'T00:00:00');
            // if event covers more than one day OR is all-day spanning >=1 day, treat as multi-day
            const daySpan = Math.round((eDate - sDate) / 86400000) + 1;
            if(daySpan >= 2){
                multiEvents.push({
                    id: it.id || `${type}-${Math.random().toString(36).slice(2,8)}`,
                    type,
                    summary: it.summary || '(Sans titre)',
                    startDateStr: sStr,
                    endDateStr: eStr,
                    startDate: sDate,
                    endDate: eDate,
                    original: it
                });
            }
        });
    });

    // allocate levels and render bands
    multiEvents.forEach(ev=>{
        // determine day indexes covered within view
        const dayIndexes = [];
        for(let d = new Date(ev.startDate); d <= ev.endDate; d = addDays(d,1)){
            const key = formatDate(d);
            if(key in dateToIndex) dayIndexes.push(dateToIndex[key]);
        }
        if(dayIndexes.length === 0) return; // out of view

        const level = allocateLevel(occupied, dayIndexes);

        // iterate days and append bands (multi-start, multi-mid, multi-end)
        dayIndexes.forEach((di, idx)=>{
            const cell = document.querySelector(`.calendar-cell[data-index="${di}"]`);
            if(!cell) return;

            // compute left/right positions proportionally inside cell:
            // We'll make bands stretch full width inside each cell (visual continuity between cells).
            // Use absolute positioning: left:6px; right:6px
            // vertical position depends on level
            const top = 22 + level * 22; // offset below date label (approx) + level spacing

            // create band element
            const band = document.createElement('div');
            band.className = `multi-band ${ev.type}`;
            band.style.transform = `translateY(${top}px)`;
            // width: full (we rely on left/right via CSS by filling cell)
            band.style.left = '6px';
            band.style.right = '6px';
            band.style.position = 'absolute';

            if(idx === 0){
                // first cell: show start time (if any) + title
                band.classList.add('multi-start');
                const startTime = ev.original.start?.dateTime ? (new Date(ev.original.start.dateTime).getHours().toString().padStart(2,'0') + ':' + new Date(ev.original.start.dateTime).getMinutes().toString().padStart(2,'0') + ' ') : '';
                band.textContent = startTime + ev.summary;
                band.setAttribute('title', ev.summary + ' — début: ' + ev.startDate.toLocaleDateString());
            } else if(idx === dayIndexes.length - 1){
                // last cell: show end time aligned right
                band.classList.add('multi-end');
                const endTime = ev.original.end?.dateTime ? ('>' + (new Date(ev.original.end.dateTime).getHours().toString().padStart(2,'0') + ':' + new Date(ev.original.end.dateTime).getMinutes().toString().padStart(2,'0'))) : '';
                band.textContent = endTime;
                band.setAttribute('title', ev.summary + ' — fin: ' + ev.endDate.toLocaleDateString());
            } else {
                // middle cell: render thinner mid bar
                band.classList.add('multi-mid');
                band.style.height = '8px';
                band.style.top = (top + 3) + 'px';
                band.textContent = '';
            }

            // ensure bands are inserted BEFORE .event elements so they stay visually below (or set z-index accordingly)
            // we append band first (so events appended later appear above); but since events may be appended afterwards,
            // we also use z-index: multi-band z-index=1, .event z-index=3 in CSS to guarantee ordering.
            cell.appendChild(band);
        });
    });
}

/* ============================================================
   RENDERING PIPELINE: combine single-day and multi-day rendering
============================================================ */
function flattenEventsForSingleDay(allEvents, start, end){
    // returns array of events that occur strictly on a single day (within view)
    const res = [];
    const cells = Array.from(document.querySelectorAll('.calendar-cell'));
    const dateToIndex = {};
    cells.forEach(c => dateToIndex[c.dataset.date] = parseInt(c.dataset.index,10));

    ['reception','navire'].forEach(type=>{
        (allEvents[type] || []).forEach(it=>{
            const sStr = getLocalDateFromGoogleEventStart(it);
            const eStr = getLocalDateFromGoogleEventEnd(it);
            if(!sStr || !eStr) return;
            const sDate = new Date(sStr + 'T00:00:00');
            const eDate = new Date(eStr + 'T00:00:00');
            const daySpan = Math.round((eDate - sDate) / 86400000) + 1;
            if(daySpan === 1){
                // falls on single day
                const key = formatDate(sDate);
                if(key in dateToIndex){
                    res.push({
                        type,
                        summary: it.summary || '(Sans titre)',
                        start: it.start,
                        end: it.end,
                        startDateStr: key,
                        original: it
                    });
                }
            }
        });
    });
    return res;
}

/* main function that builds grid, clears previous, fetches and renders events */
async function loadCalendar(){
    const today = new Date();
    const mondayCurrent = getStartMonday(today);

    // start = monday of previous week + offsetWeeks*7 (for ordering: past / current / future)
    const start = new Date(mondayCurrent);
    start.setDate(start.getDate() - 7 + offsetWeeks*7);

    const end = addDays(start, viewDays - 1);
    document.getElementById('calendar-title').textContent = formatMonthRange(start, end);

    // create grid (clears previous)
    createGrid(start, viewDays);

    // fetch with hash/cache
    try {
        const events = await fetchCalendarWithHash(start, end);

        // render single-day events first (will visually be above multi-day due z-index)
        const singleDay = flattenEventsForSingleDay(events, start, end);
        renderSingleDayEvents(singleDay);

        // then render multi-day bands (they are below because multi-band z-index=1)
        renderMultiDayBands(events, start, viewDays);

    } catch(err){
        console.error('Erreur loadCalendar:', err);
    }
}

/* =====================
   NAVIGATION CALENDRIER
===================== */
document.getElementById("prev-btn").onclick = ()=>{ offsetWeeks -= 1; loadCalendar(); };
document.getElementById("next-btn").onclick = ()=>{ offsetWeeks += 1; loadCalendar(); };
document.getElementById("today-btn").onclick = ()=>{ offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-3w").onclick = ()=>{ viewDays = 21; offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-4w").onclick = ()=>{ viewDays = 28; offsetWeeks = 0; loadCalendar(); };

/* initial load + auto-refresh (fetchCalendarWithHash évite appels inutiles si pas de changement) */
loadCalendar();
setInterval(loadCalendar, CAL_REFRESH_INTERVAL);

/* ============================================================
   PONTS HAROPA
   (PARTIE CONSERVÉE TELLE QUE DANS TON CODE — AUCUNE MODIFICATION)
============================================================ */
const CACHE_KEY_DATA="pontsData";
const CACHE_KEY_HASH="pontsHash";
const CACHE_KEY_TIME="pontsCacheTime";
const CACHE_EXPIRATION=60000;
const REFRESH_INTERVAL=10000;

const PROXIES=[
    "https://api.allorigins.win/get?url=",
    "https://cors-anywhere.herokuapp.com/",
    "https://thingproxy.freeboard.io/fetch/"
];

async function sha256(str){
    const data=new TextEncoder().encode(str);
    const digest=await crypto.subtle.digest("SHA-256",data);
    return Array.from(new Uint8Array(digest))
        .map(b=>b.toString(16).padStart(2,"0"))
        .join("");
}

async function fetchWithRandomProxy(url) {
    const shuffled = [...PROXIES].sort(() => Math.random() - 0.5);

    for (const proxy of shuffled) {
        try {
            const fullUrl = proxy + encodeURIComponent(url);
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);

            const res = await fetch(fullUrl, { signal: controller.signal });
            clearTimeout(timeout);
            if (!res.ok) throw new Error(`Proxy failed: ${res.status}`);

            let txt = await res.text();

            // allOrigins format
            try {
                const parsed = JSON.parse(txt);
                if (parsed.contents) return parsed.contents;
            } catch {}

            return txt;
        }
        catch(err){
            console.warn(`Proxy ${proxy} échoué : ${err.message}`);
        }
    }

    throw new Error("Tous les proxys ont échoué");
}

async function checkAndUpdate(){
    const now = Date.now();
    const last = localStorage.getItem(CACHE_KEY_TIME);

    if (last && now-last < CACHE_EXPIRATION){
        const cached = localStorage.getItem(CACHE_KEY_DATA);
        if (cached){
            renderPonts(JSON.parse(cached));
            return;
        }
    }

    await fetchWithHashControl();
}

async function fetchWithHashControl(){
    try{
        const rawContent = await fetchWithRandomProxy("https://www.havre-port.com/map/getPonts");
        const newHash = await sha256(rawContent);
        const oldHash = localStorage.getItem(CACHE_KEY_HASH);

        if (newHash === oldHash && localStorage.getItem(CACHE_KEY_DATA)){
            renderPonts(JSON.parse(localStorage.getItem(CACHE_KEY_DATA)));
            return;
        }

        const ponts = Object.values(JSON.parse(rawContent).data);

        /* Correction tri */
        const unique = Array.from(new Map(ponts.map(p=>[p.nom,p])).values());
        const ordered = unique.sort((a,b)=>{
            const score=p=>{
                const s=p.statutText.toLowerCase();
                if(s.includes("fermeture")) return 1;
                if(s.includes("fermé")) return 2;
                if(s.includes("manoeuvre")) return 3;
                if(s.includes("ouvert")) return 4;
                return 5;
            };
            return score(a)-score(b);
        });

        localStorage.setItem(CACHE_KEY_DATA,JSON.stringify(ordered));
        localStorage.setItem(CACHE_KEY_HASH,newHash);
        localStorage.setItem(CACHE_KEY_TIME,Date.now());

        renderPonts(ordered);
    }
    catch(err){
        console.error("Erreur récupération ponts:",err);
        document.getElementById("ponts-table").textContent="Impossible de récupérer les ponts.";
    }
}

function renderPonts(list){
    const container=document.getElementById("ponts-table");
    container.innerHTML=list.map(p=>{
        const s=p.statutText.toLowerCase();

        const cls =
            s.includes("fermeture") ? "fermeture" :
            s.includes("fermé")      ? "ferme" :
            s.includes("manoeuvre")  ? "manoeuvre" :
            s.includes("ouvert")     ? "ouvert" : "ferme";

        const info = p.forceText || `MàJ : ${p.date}`;

        return `
            <div class="pont-card ${cls}">
                <div class="pont-nom"><span class="pastille"></span>${p.nom}</div>
                <div class="pont-etat">${p.statutText}</div>
                <div class="pont-infos">${info}</div>
            </div>`;
    }).join("");
}

checkAndUpdate();
setInterval(checkAndUpdate,REFRESH_INTERVAL);
</script>
</body>
</html>
