<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ponts HAROPA – Monitoring + Calendrier</title>
<style>
/* =====================
   GLOBAL
===================== */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #101010;
    color: #eaeaea;
    display: flex;
    height: 100vh;
    overflow: hidden;
}
.left { 
    flex: 0 0 20%;
    border-right: 1px solid #444; 
    padding: 14px; 
    overflow-y: auto; 
    box-sizing: border-box;
}
.right { 
    flex: 1;  
    padding: 10px; 
    overflow-y: auto; 
}
.container { height: 100%; }
h2 {
    text-align: center;
    color: #00e5ff;
    margin: 0 0 15px;
}
#calendar-container { height: 100%; overflow-y: auto; }

/* =====================
   CARTES PONTS
===================== */
#ponts-table { display: flex; flex-direction: column; gap: 10px; }
.pont-card {
    background: #1f1f1f;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 0 5px rgba(0,0,0,0.4);
    border-left: 4px solid #444;
    transition: transform 0.15s ease, box-shadow 0.3s ease;
}
.pont-card:hover { transform: scale(1.02); }
.pont-card.ferme { border-left-color: #ff4040; }
.pont-card.fermeture { border-left-color: orange; animation: pulse-orange 1.2s infinite; }
.pont-card.manoeuvre { border-left-color: #1c3cff; animation: pulse-blue 1.2s infinite; }
.pont-card.ouvert { border-left-color: #58ff58; }
.pastille { width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; display: inline-block; }
.ferme .pastille    { background: #ff4040; }
.fermeture .pastille { background: orange; }
.manoeuvre .pastille { background: #1c3cff; }
.ouvert .pastille   { background: #58ff58; }
.pont-nom { font-weight: bold; display: flex; align-items: center; }
@keyframes pulse-blue {
    0%,100% { box-shadow: 0 0 5px rgba(28,60,255,0.4); transform: scale(1); }
    50% { box-shadow: 0 0 20px rgba(28,60,255,0.7); transform: scale(1.02); }
}
@keyframes pulse-orange {
    0%,100% { box-shadow: 0 0 5px rgba(255,165,0,0.4); transform: scale(1); }
    50% { box-shadow: 0 0 20px rgba(255,165,0,0.7); transform: scale(1.02); }
}

/* =====================
   CARTES ÉVÉNEMENTS CALENDRIER
===================== */
.event-card {
    background: #1f1f1f;
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 10px;
    box-shadow: 0 0 5px rgba(0,0,0,0.4);
}
.event-title { font-weight: bold; color: #00e5ff; }
.event-time { font-size: 0.9em; color: #ccc; margin-top: 4px; }
</style>
</head>
<body>

<!-- =====================
     COLONNE GAUCHE - PONTS
===================== -->
<div class="left">
    <div class="container">
        <h2>État des Ponts</h2>
        <div id="ponts-table">Chargement...</div>
    </div>
</div>

<!-- =====================
     COLONNE DROITE - CALENDRIER
===================== -->
<div class="right">
    <h2>Calendrier</h2>
    <div id="calendar-container">Chargement...</div>
</div>

<script>
// =====================
// CONFIGURATION PONTS
// =====================
const CACHE_KEY_DATA = "pontsData";
const CACHE_KEY_HASH = "pontsHash";
const CACHE_KEY_TIME = "pontsCacheTime";
const CACHE_EXPIRATION = 120000;
const REFRESH_INTERVAL = 60000;

const PROXIES = [
    "https://api.allorigins.win/get?url=",
    "https://cors-anywhere.herokuapp.com/",
    "https://thingproxy.freeboard.io/fetch/"
];

async function sha256(str) {
    const data = new TextEncoder().encode(str);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(digest))
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");
}

async function fetchWithRandomProxy(url) {
    const shuffledProxies = [...PROXIES].sort(() => Math.random() - 0.5);
    for (const proxy of shuffledProxies) {
        try {
            const fullUrl = proxy + encodeURIComponent(url);
            const res = await fetch(fullUrl);
            if (!res.ok) throw new Error(`Proxy failed: ${res.status}`);
            const data = await res.json();
            return data.contents ? data.contents : data;
        } catch (err) {
            console.warn(`Échec du proxy ${proxy}:`, err.message);
        }
    }
    throw new Error("Tous les proxys ont échoué");
}

async function checkAndUpdate() {
    const now = Date.now();
    const last = localStorage.getItem(CACHE_KEY_TIME);
    if (last && now - last < CACHE_EXPIRATION) {
        const cached = localStorage.getItem(CACHE_KEY_DATA);
        if (cached) { renderPonts(JSON.parse(cached)); return; }
    }
    await fetchWithHashControl();
}

async function fetchWithHashControl() {
    try {
        const rawContent = await fetchWithRandomProxy("https://www.havre-port.com/map/getPonts");
        const newHash = await sha256(rawContent);
        const oldHash = localStorage.getItem(CACHE_KEY_HASH);

        if (newHash === oldHash) {
            const cached = localStorage.getItem(CACHE_KEY_DATA);
            if (cached) { renderPonts(JSON.parse(cached)); return; }
        }

        const ponts = Object.values(JSON.parse(rawContent).data);
        const unique = Array.from(new Map(ponts.map(p => [p.nom, p])).values());
        const ordered = unique.sort((a, b) => {
            const score = p => {
                const statut = p.statutText.toLowerCase();
                if (statut.includes("fermé")) return 1;
                if (statut.includes("fermeture")) return 2;
                if (statut.includes("manoeuvre")) return 3;
                if (statut.includes("ouvert")) return 4;
                return 5;
            };
            return score(a) - score(b);
        });

        localStorage.setItem(CACHE_KEY_DATA, JSON.stringify(ordered));
        localStorage.setItem(CACHE_KEY_HASH, newHash);
        localStorage.setItem(CACHE_KEY_TIME, Date.now());
        renderPonts(ordered);

    } catch (err) {
        console.error("Erreur récupération ponts:", err);
        document.getElementById("ponts-table").textContent = "Impossible de récupérer les ponts.";
    }
}

function renderPonts(list) {
    const container = document.getElementById("ponts-table");
    container.innerHTML = list.map(p => {
        const statut = p.statutText.toLowerCase();
        const open = statut.includes("ouvert");
        const move = statut.includes("manoeuvre");
        const fermeture = statut.includes("fermeture");
        const ferme = statut.includes("fermé");
        const cls = ferme ? "ferme" : fermeture ? "fermeture" : move ? "manoeuvre" : open ? "ouvert" : "ferme";
        const info = p.forceText || `MàJ : ${p.date}`;

        return `
            <div class="pont-card ${cls}">
                <div class="pont-nom">
                    <span class="pastille"></span>${p.nom}
                </div>
                <div class="pont-etat">${p.statutText}</div>
                <div class="pont-infos">${info}</div>
            </div>
        `;
    }).join("");
}

checkAndUpdate();
setInterval(checkAndUpdate, REFRESH_INTERVAL);

// =====================
// GOOGLE CALENDAR API
// =====================
const API_KEY = "AIzaSyDkQkqPoOGf8umYg2dbeTU0THfLlJnCjXo";
const CALENDAR_ID = "cmVjZXB0aW9ucm91bGllckBnbWFpbC5jb20"; // exemple calendrier public
const CALENDAR_CONTAINER = document.getElementById("calendar-container");

function formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString("fr-FR", { 
        weekday: "short", year:"numeric", month:"short", day:"numeric", hour:"2-digit", minute:"2-digit" 
    });
}

async function fetchEvents() {
    const now = new Date().toISOString();
    const maxTime = new Date(Date.now() + 7*24*60*60*1000).toISOString(); // 7 jours
    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(CALENDAR_ID)}/events?key=${API_KEY}&timeMin=${now}&timeMax=${maxTime}&singleEvents=true&orderBy=startTime`;

    try {
        const res = await fetch(url);
        const data = await res.json();
        return data.items || [];
    } catch (err) {
        console.error("Erreur API Google Calendar:", err);
        return [];
    }
}

async function renderEvents() {
    const events = await fetchEvents();
    CALENDAR_CONTAINER.innerHTML = events.map(ev => {
        const start = formatDate(ev.start.dateTime || ev.start.date);
        const end = formatDate(ev.end.dateTime || ev.end.date);
        return `
            <div class="event-card">
                <div class="event-title">${ev.summary || "Sans titre"}</div>
                <div class="event-time">${start} → ${end}</div>
            </div>
        `;
    }).join("");
}

// Rafraîchissement automatique toutes les 30 secondes
renderEvents();
setInterval(renderEvents, 30000);
</script>

</body>
</html>
