<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Calendrier & État des Ponts</title>
<style>
/* ================= GLOBAL ================= */
:root{
  --bg:#121212; --card:#1c1f23; --accent:#00e5ff; --muted:#999; --gap:6px;
}
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family: Inter, system-ui, Arial, sans-serif;
  background:var(--bg); color:#eaeaea; height:100vh; display:flex;
}
.container{flex:1;display:flex;overflow:hidden}

/* LEFT (ponts) */
#ponts-panel{
  flex:0 0 280px; /* resserré */
  padding:16px; border-right:1px solid #555; overflow:auto;
  background: #0f1113;
}
#ponts-panel h2{ color:var(--accent); text-align:center; margin-bottom:12px; font-size:18px;}
#ponts-table{display:flex;flex-direction:column;gap:10px}
.pont-card{
  background:#1f1f1f;padding:10px;border-radius:8px;border-left:4px solid #444;
  box-shadow:0 0 6px rgba(0,0,0,0.5); transition:transform .12s;
}
.pont-card:hover{ transform:scale(1.02) }
.pont-card.ferme{ border-left-color:#ff4040 }
.pont-card.ouvert{ border-left-color:#58ff58 }
.pont-card.manoeuvre{ border-left-color:#1c3cff; animation:pulse 1.2s infinite }
.pastille{ width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px}
.ferme .pastille{background:#ff4040}
.ouvert .pastille{background:#58ff58}
.manoeuvre .pastille{background:#1c3cff}
.pont-nom{ font-weight:700; display:flex; align-items:center; gap:8px}

/* RIGHT (calendar) */
#calendar-panel{ flex:1; display:flex; flex-direction:column; padding:16px; overflow:auto; }
header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:10px; flex-wrap:wrap }
header h1{ color:var(--accent); font-size:20px }
.nav-buttons{ display:flex; gap:8px; align-items:center }
.nav-buttons button, .nav-buttons select{
  background:none;border:none;color:var(--accent);cursor:pointer;padding:6px 8px;border-radius:6px;
}
.nav-buttons button:hover, .nav-buttons select:hover{ background: rgba(0,229,255,0.08) }

.calendar{ background:var(--card); border-radius:12px; flex:1; padding:8px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); overflow:hidden; display:flex; flex-direction:column }
.grid{ display:grid; grid-template-columns: repeat(7,1fr); gap:var(--gap); flex:1; }

/* day cell */
.day{
  background:#141619;border-radius:12px;padding:8px;border:1px solid #444; display:flex; flex-direction:column; position:relative; overflow:visible;
  transition: transform .18s ease, box-shadow .2s;
  min-height:88px;
}
.day-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-size:13px }
.day .date{ font-weight:700 }
.day.past{ opacity:.82; transform:scale(.995) }
.day.today{ z-index:3; transform:scale(1.03); border:2px solid var(--accent); background:#1f2226; animation: todayPulse 3s infinite ease-in-out }
.day.future{ animation: futurePulse 3.6s infinite ease-in-out }

/* events list */
.events{ display:flex; flex-direction:column; gap:6px; overflow:visible }

/* normal event */
.event{
  display:flex; gap:8px; align-items:flex-start; padding:6px 8px; border-radius:8px; background: rgba(0,0,0,0.28);
  cursor:pointer; word-break:break-word; white-space:normal; font-size:13px;
}
.event .time{ font-weight:700; font-size:12px; min-width:56px; color:#dcdcdc; flex:0 0 auto }
.event .title{ flex:1 1 auto; line-height:1.15; color:#fff }

/* more indicator */
.event.more{ background:transparent; color:var(--muted); padding-left:8px; font-size:13px }

/* multi-day: middle, start, end */
.event.multi-day{ border-radius:0; padding:6px 8px; display:flex; align-items:center; gap:8px; }
.event.multi-day.start{ border-top-left-radius:8px; border-bottom-left-radius:8px; }
.event.multi-day.end{ border-top-right-radius:8px; border-bottom-right-radius:8px; }

/* per-calendar color tags (text color only; background left to design) */
.c-reception{ color:#109c53 }
.c-smr{ color:#5768cb }

/* popup */
#popup{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  background:var(--card); padding:16px; border-radius:10px; box-shadow:0 12px 40px rgba(0,0,0,0.7); z-index:9999; display:none; min-width:300px;
}
#popup .close{ position:absolute; right:10px; top:8px; cursor:pointer; font-weight:700 }
#popup h3{ margin-bottom:8px }

/* animations */
@keyframes todayPulse{ 0%,100%{ transform: scale(1.03) } 50%{ transform: scale(1.06) } }
@keyframes futurePulse{ 0%,100%{ box-shadow:0 0 6px rgba(0,229,255,0.06) } 50%{ box-shadow:0 0 10px rgba(0,229,255,0.12) } }
@keyframes pulse{ 0%{ box-shadow:0 0 6px rgba(28,60,255,0.25) } 50%{ box-shadow:0 0 20px rgba(28,60,255,0.55) } 100%{ box-shadow:0 0 6px rgba(28,60,255,0.25) } }

@media(max-width:1100px){
  .container{ flex-direction:column }
  #ponts-panel{ order:1; width:100%; max-width:none; border-right:none; border-bottom:1px solid #333 }
  #calendar-panel{ order:2 }
}
</style>
</head>
<body>

<div class="container">
  <!-- LEFT : ponts -->
  <aside id="ponts-panel">
    <h2>État des Ponts</h2>
    <div id="ponts-table">Chargement...</div>
  </aside>

  <!-- RIGHT : calendrier -->
  <main id="calendar-panel">
    <header>
      <h1 id="month-title">Mois</h1>
      <div class="nav-buttons">
        <button id="prev-week" aria-label="Semaine précédente">&lt;</button>
        <button id="today-btn">Aujourd'hui</button>
        <button id="next-week" aria-label="Semaine suivante">&gt;</button>
        <select id="weeks-select" title="Nombre de semaines">
          <option value="3">3 semaines</option>
          <option value="4" selected>4 semaines</option>
        </select>
      </div>
    </header>

    <section class="calendar">
      <div class="grid" id="grid"></div>
    </section>
  </main>
</div>

<!-- Popup -->
<div id="popup" role="dialog" aria-modal="true">
  <button class="close" onclick="popup.style.display='none'">×</button>
  <h3 id="popup-title"></h3>
  <div id="popup-time"></div>
</div>

<script>
/* ----------------------------------------------------------------------
  CONFIG - Remplace l'API KEY par ta clé Google (lecture publique).
  Si tes calendriers ne sont pas publics, il faut un backend OAuth.
------------------------------------------------------------------------ */
const API_KEY = 'YOUR_GOOGLE_API_KEY'; // <-- REMPLACE ICI
const CALENDARS = [
  { id:'receptionroulier@gmail.com', key:'reception', css:'c-reception' },
  { id:'smr.programme@gmail.com', key:'smr', css:'c-smr' }
];

/* Ponts proxy (utilise corsproxy.io). Si tu as un backend, remplace par ton endpoint */
const PONTS_PROXY_BASE = 'https://corsproxy.io/?';

/* Cache / options */
const PONT_CACHE_TTL = 120000; // ms
const PONT_REFRESH = 60000;
const CAL_CACHE_TTL = 120000;
const CAL_CACHE_KEYS = {
  payload: 'cal_cache_payload_v1',
  hash: 'cal_cache_hash_v1',
  ts: 'cal_cache_ts_v1'
};

/* ----------------- UTILITAIRES DATE (local) ----------------- */
const pad = n => String(n).padStart(2,'0');

function fmtDateLocal(d){
  // accepte Date ou string
  if (!(d instanceof Date)) d = new Date(d);
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
function fmtDisplayDate(d){
  if(!(d instanceof Date)) d = new Date(d);
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}`;
}
function fmtTime(dt){
  if(!dt) return '';
  const d = (dt instanceof Date) ? dt : new Date(dt);
  return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

/* ----------------- PONTS (fetch via proxy stable) ----------------- */
const PONT_CACHE_KEY = 'pontsData';
const PONT_HASH_KEY = 'pontsHash';
const PONT_TS_KEY = 'pontsCacheTime';

async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

function renderPonts(list){
  const container = document.getElementById('ponts-table');
  container.innerHTML = list.map(p=>{
    const s = (p.statutText||'').toLowerCase();
    const open = s.includes('ouvert');
    const move = s.includes('manoeuvre') || s.includes('manoeuvr');
    const cls = move ? 'manoeuvre' : open ? 'ouvert' : 'ferme';
    const info = p.forceText || `MàJ : ${p.date||''}`;
    return `<div class="pont-card ${cls}">
      <div class="pont-nom"><span class="pastille"></span>${p.nom}</div>
      <div class="pont-etat">${p.statutText||''}</div>
      <div class="pont-infos">${info}</div>
    </div>`;
  }).join('');
}

async function fetchPonts(){
  try{
    const target = 'https://www.havre-port.com/map/getPonts';
    const url = PONTS_PROXY_BASE + encodeURIComponent(target);
    const res = await fetch(url);
    if(!res.ok) throw new Error('proxy error '+res.status);
    const txt = await res.text();
    // corsproxy.io renvoie contenu brut (ici JSON), parfois encodé ; on parse en JSON
    const json = JSON.parse(txt);
    const arr = Object.values(json.data || {});
    // dedupe by name
    const unique = Array.from(new Map(arr.map(p=>[p.nom,p])).values());
    const ordered = unique.sort((a,b)=>{
      const score = p=>{
        const s=(p.statutText||'').toLowerCase();
        if(s.includes('manoeuvre')||s.includes('manoeuv')) return 1;
        if(s.includes('ouvert')) return 2;
        return 0;
      };
      return score(a)-score(b);
    });
    localStorage.setItem(PONT_CACHE_KEY, JSON.stringify(ordered));
    localStorage.setItem(PONT_HASH_KEY, await sha256Hex(JSON.stringify(ordered)));
    localStorage.setItem(PONT_TS_KEY, Date.now().toString());
    renderPonts(ordered);
  }catch(err){
    console.error('Erreur Ponts:', err);
    const cached = localStorage.getItem(PONT_CACHE_KEY);
    if(cached) renderPonts(JSON.parse(cached));
    else document.getElementById('ponts-table').textContent = 'Impossible de récupérer les ponts.';
  }
}

async function checkAndUpdatePonts(){
  const ts = parseInt(localStorage.getItem(PONT_TS_KEY)||'0',10);
  if(ts && Date.now()-ts < PONT_CACHE_TTL){
    const cached = localStorage.getItem(PONT_CACHE_KEY);
    if(cached){ renderPonts(JSON.parse(cached)); return; }
  }
  await fetchPonts();
}
checkAndUpdatePonts();
setInterval(checkAndUpdatePonts, PONT_REFRESH);

/* ----------------- CALENDAR ----------------- */
let WEEKS = 4;
let gridStartDate;
const gridEl = document.getElementById('grid');
const monthTitle = document.getElementById('month-title');
const popup = document.getElementById('popup');
const popupTitle = document.getElementById('popup-title');
const popupTime = document.getElementById('popup-time');
const weeksSelect = document.getElementById('weeks-select');
const prevBtn = document.getElementById('prev-week');
const nextBtn = document.getElementById('next-week');
const todayBtn = document.getElementById('today-btn');

function computeGridStart(refDate){
  const d = new Date(refDate);
  d.setHours(0,0,0,0);
  const day = d.getDay();
  const mondayThisWeek = new Date(d);
  mondayThisWeek.setDate(d.getDate() - ((day + 6) % 7)); // local Monday
  const mondayLastWeek = new Date(mondayThisWeek);
  mondayLastWeek.setDate(mondayLastWeek.getDate() - 7);
  return mondayLastWeek;
}

/* cache helpers */
function loadCalCache(){
  try{
    const raw = localStorage.getItem(CAL_CACHE_KEYS.payload);
    if(!raw) return null;
    const ts = parseInt(localStorage.getItem(CAL_CACHE_KEYS.ts)||'0',10);
    if(!ts || (Date.now()-ts)>CAL_CACHE_TTL) return null;
    return JSON.parse(raw);
  }catch{ return null; }
}
function saveCalCache(payload){
  try{
    localStorage.setItem(CAL_CACHE_KEYS.payload, JSON.stringify(payload));
    localStorage.setItem(CAL_CACHE_KEYS.ts, Date.now().toString());
  }catch{}
}
function getCalHash(){ return localStorage.getItem(CAL_CACHE_KEYS.hash); }
function setCalHash(h){ try{ localStorage.setItem(CAL_CACHE_KEYS.hash,h); }catch{} }
async function sha256HexLocal(str){ return await sha256Hex(str); }

/* fetch events for a calendar */
async function fetchEventsForCalendar(calId, timeMin, timeMax){
  const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calId)}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime&maxResults=2500`;
  const res = await fetch(url);
  if(!res.ok){
    const txt = await res.text().catch(()=>null);
    throw new Error('Google API error '+res.status+' '+(txt||''));
  }
  const data = await res.json();
  return data.items||[];
}

/* getEvents with cache+hash */
async function getEvents(timeMin, timeMax){
  const cached = loadCalCache();
  if(cached) return cached;
  const all = {};
  for(const cal of CALENDARS){
    try{ all[cal.key] = await fetchEventsForCalendar(cal.id, timeMin, timeMax); }
    catch(err){ console.warn('fetch calendar',cal.id,err); all[cal.key]=[]; }
  }
  const stable = {};
  Object.keys(all).sort().forEach(k=> stable[k]=all[k]);
  const payloadStr = JSON.stringify(stable);
  const newHash = await sha256HexLocal(payloadStr);
  const oldHash = getCalHash();
  if(oldHash && oldHash === newHash){
    // use stored payload if exists
    const raw = localStorage.getItem(CAL_CACHE_KEYS.payload);
    if(raw){
      localStorage.setItem(CAL_CACHE_KEYS.ts, Date.now().toString());
      return JSON.parse(raw);
    }
  }
  saveCalCache(all);
  setCalHash(newHash);
  return all;
}

/* render calendar */
async function renderCalendar(){
  const dates = [];
  for(let w=0; w<WEEKS; w++){
    for(let i=0;i<7;i++){
      const d = new Date(gridStartDate);
      d.setDate(d.getDate() + w*7 + i);
      d.setHours(0,0,0,0);
      dates.push(d);
    }
  }

  gridEl.style.gridTemplateRows = `repeat(${WEEKS},1fr)`;
  gridEl.innerHTML = '';

  dates.forEach(d=>{
    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    dayEl.dataset.date = fmtDateLocal(d);
    dayEl.innerHTML = `<div class="day-header"><div>${['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'][d.getDay()]}</div><div class="date">${d.getDate()}</div></div><div class="events"></div>`;
    gridEl.appendChild(dayEl);
  });

  // time bounds in ISO - we pass full local-day bounds as ISO strings (Google expects RFC3339 UTC offset ok)
  const timeMin = new Date(dates[0]); timeMin.setHours(0,0,0,0);
  const timeMax = new Date(dates[dates.length-1]); timeMax.setHours(23,59,59,999);

  // Fetch events
  let fetched;
  try{
    fetched = await getEvents(timeMin.toISOString(), timeMax.toISOString());
  }catch(err){
    console.error('Erreur fetch calendar', err);
    fetched = {}; // proceed with empty
  }

  // Build eventsByDay with local date keys
  const eventsByDay = {};
  const seen = new Set();
  for(const calKey in fetched){
    for(const ev of fetched[calKey] || []){
      const dedupe = ev.iCalUID || ev.id || (ev.summary||'') + (ev.start?.date || ev.start?.dateTime || '');
      if(seen.has(dedupe)) continue;
      seen.add(dedupe);

      const allDay = !!ev.start?.date;
      let startDate, endDate;
      if(allDay){
        // Google all-day : start.date and end.date (end exclusive)
        startDate = new Date(ev.start.date);
        endDate = new Date(ev.end.date);
        // ensure local midnight
        startDate.setHours(0,0,0,0);
        endDate.setHours(0,0,0,0);
      } else {
        startDate = new Date(ev.start.dateTime);
        endDate = new Date(ev.end.dateTime);
      }

      // iterate local days from start (inclusive) to end (exclusive)
      const s = new Date(startDate);
      const e = new Date(endDate);
      // If end equals start (rare), ensure at least one slot
      if(e.getTime() === s.getTime()){
        // single instant event (same day)
        const key = fmtDateLocal(s);
        eventsByDay[key] = eventsByDay[key] || [];
        eventsByDay[key].push({
          title: ev.summary || '(sans titre)',
          start: startDate,
          end: endDate,
          allDay: allDay,
          calendarKey: calKey,
          multiDay: false,
          date: new Date(s)
        });
      } else {
        for(let d = new Date(s); d < e; d.setDate(d.getDate()+1)){
          const key = fmtDateLocal(d);
          eventsByDay[key] = eventsByDay[key] || [];
          eventsByDay[key].push({
            title: ev.summary || '(sans titre)',
            start: startDate,
            end: endDate,
            allDay: allDay,
            calendarKey: calKey,
            multiDay: (Math.floor((e - s) / (24*3600*1000)) >= 1),
            date: new Date(d) // the cell day
          });
        }
      }
    }
  }

  // Render events into cells, and mark multi-day start/end
  document.querySelectorAll('.day').forEach(dayEl=>{
    const date = dayEl.dataset.date;
    const evList = eventsByDay[date] || [];
    const container = dayEl.querySelector('.events');
    container.innerHTML = '';

    // For consistent ordering, sort by start time (allDay first)
    evList.sort((a,b)=>{
      if(a.allDay && !b.allDay) return -1;
      if(!a.allDay && b.allDay) return 1;
      return (a.start?.getTime() || 0) - (b.start?.getTime() || 0);
    });

    // Append each event, detect multi-day start/end
    evList.forEach(ev=>{
      const calMeta = CALENDARS.find(c=>c.key===ev.calendarKey);
      const el = document.createElement('div');
      let cls = 'event ' + (ev.allDay ? 'allDay ' : '') + (calMeta ? calMeta.css : '');
      if(ev.multiDay){
        // determine if this cell is start/end/intermediate
        const startDate = new Date(ev.start); startDate.setHours(0,0,0,0);
        const endDate = new Date(ev.end); endDate.setHours(0,0,0,0);
        const cur = new Date(ev.date); cur.setHours(0,0,0,0);
        if(fmtDateLocal(cur) === fmtDateLocal(startDate)) cls += ' multi-day start';
        else if(fmtDateLocal(cur) === fmtDateLocal(new Date(endDate.getTime() - 1))) cls += ' multi-day end';
        else cls += ' multi-day';
      }
      el.className = cls.trim();
      const timeText = ev.allDay ? '' : fmtTime(ev.start);
      el.innerHTML = `<div class="time">${timeText}</div><div class="title">${ev.title}</div>`;
      el.onclick = ()=>{
        const startDisp = fmtDisplayDate(ev.start);
        const endDisp = fmtDisplayDate(new Date(ev.end.getTime() - 1)); // show inclusive last day
        const hours = ev.allDay ? 'Toute la journée' : `${fmtTime(ev.start)} → ${fmtTime(ev.end)}`;
        popupTitle.textContent = ev.title;
        popupTime.innerHTML = `<strong>Début :</strong> ${startDisp}<br><strong>Fin :</strong> ${endDisp}<br><strong>Heures :</strong> ${hours}`;
        popup.style.display = 'block';
      };
      container.appendChild(el);
    });

    // if many events, show "+ X autres"
    if(evList.length > 6){
      const more = document.createElement('div');
      more.className = 'event more';
      more.textContent = `+ ${evList.length - 6} autres`;
      container.appendChild(more);
    }
  });

  // mark past/today/future
  const todayStr = fmtDateLocal(new Date());
  document.querySelectorAll('.day').forEach(dayEl=>{
    const d = dayEl.dataset.date;
    dayEl.classList.remove('past','today','future');
    if(d === todayStr) dayEl.classList.add('today');
    else if(d < todayStr) dayEl.classList.add('past');
    else dayEl.classList.add('future');
  });

  // month title from first date
  const months = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
  monthTitle.textContent = months[dates[0].getMonth()] + ' ' + dates[0].getFullYear();
}

/* NAV */
prevBtn.onclick = ()=>{ gridStartDate.setDate(gridStartDate.getDate()-7); renderCalendar(); };
nextBtn.onclick = ()=>{ gridStartDate.setDate(gridStartDate.getDate()+7); renderCalendar(); };
todayBtn.onclick = ()=>{ gridStartDate = computeGridStart(new Date()); renderCalendar(); };
weeksSelect.onchange = e => { WEEKS = parseInt(e.target.value,10); renderCalendar(); };

/* INIT */
gridStartDate = computeGridStart(new Date());
renderCalendar();
setInterval(renderCalendar, 60000);

/* close popup on outside click or Esc */
document.addEventListener('keydown', e => { if(e.key === 'Escape') popup.style.display='none' });
document.addEventListener('click', e => { if(e.target === popup) popup.style.display='none' });

</script>
</body>
</html>
