<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ponts HAROPA – Monitoring + Calendrier</title>
<style>
/* =====================
   GLOBAL
===================== */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #101010;
    color: #eaeaea;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

/* =====================
   COLONNE GAUCHE
===================== */
.left {
    flex: 0 0 20%;
    border-right: 1px solid #444;
    padding: 14px;
    overflow-y: auto;
    box-sizing: border-box;
}
.left h2 { color: #00e5ff; text-align: center; }

/* =====================
   CARTES PONTS
   (styles inchangés)
===================== */
.pont-card {
    background: #1f1f1f;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 0 5px rgba(0,0,0,0.4);
    border-left: 4px solid #444;
    transition: transform 0.15s ease, box-shadow 0.3s ease;
    margin-bottom: 8px;
}
.pont-card:hover { transform: scale(1.02); }

.pont-card.ferme { border-left-color: #ff4040; }
.pont-card.fermeture { border-left-color: orange; animation: pulse-orange 1.2s infinite; }
.pont-card.manoeuvre { border-left-color: #1c3cff; animation: pulse-blue 1.2s infinite; }
.pont-card.ouvert { border-left-color: #58ff58; }

.pastille { width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; display: inline-block; }
.ferme .pastille      { background: #ff4040; }
.fermeture .pastille  { background: orange; }
.manoeuvre .pastille  { background: #1c3cff; }
.ouvert .pastille     { background: #58ff58; }

.pont-nom { font-weight: bold; display: flex; align-items: center; }

/* =====================
   CALENDRIER
===================== */
.right { flex:1; display:flex; flex-direction:column; height:100%; overflow:hidden; }
#calendar-header { flex:0 0 auto; padding:12px; text-align:center; font-size:22px; color:#00e5ff; border-bottom:1px solid #333; display:flex; justify-content:center; align-items:center; gap:18px; }
.nav-btn { cursor:pointer; color:#00e5ff; font-size:26px; padding:4px 10px; border-radius:6px; transition:0.2s; }
.nav-btn:hover { background:#222; }
.view-btn { cursor:pointer; font-size:14px; padding:4px 10px; background:#222; border-radius:6px; border:1px solid #333; color:#00e5ff; }
.view-btn:hover { background:#333; }

/* make grid position:relative so bands can be positioned across columns (continuous) */
#calendar-grid { flex:1 1 auto; display:grid; gap:1px; background:#333; overflow:auto; box-sizing:border-box; padding:6px; position:relative; }

/* cells keep relative pos */
.calendar-cell {
    background:#1a1a1a;
    padding:6px;
    border:1px solid #222;
    overflow:visible;
    position:relative;
    min-height:70px;
    box-sizing:border-box;
}
.date-label { font-size:12px; font-weight:normal; margin-bottom:4px; color:#ffffff; }

/* ponctuels (au-dessus) */
.event {
    position:relative;
    z-index: 4; /* au-dessus des bandes multi-jours */
    padding:3px 5px;
    border-radius:4px;
    font-size:12px;
    margin-bottom:4px;
}
.event.reception { background:#109c5344; border-left:3px solid #109c53; }
.event.navire     { background:#3644b344; border-left:3px solid #3644b3; }
.event-time { font-size:12px;font-weight:normal; margin-right:4px; }

/* =====================
   BANDES MULTI-JOURS CONTINUES
   - sont positionnées ABSOLUTE sur #calendar-grid (une seule DIV par événement)
   - z-index plus bas pour rester dessous
===================== */
.multi-band {
  position:absolute;
  height:20px;               /* hauteur de la bande */
  border-radius:6px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:0 8px;
  box-sizing:border-box;
  font-size:12px;
  color:#fff;
  z-index:2;                 /* sous les events mais au-dessus du fond */
  overflow:hidden;
}

/* couleurs pleines pour bandes (remplissage) */
.multi-band.reception { background: #109c53; }
.multi-band.navire    { background: #3644b3; }

/* texte start (left) and end (right) */
.multi-band .left { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-weight:600; }
.multi-band .right { white-space:nowrap; margin-left:8px; }

/* small mid indicator if needed (not used with continuous band but kept for fallback) */
.multi-mid { height:10px; border-radius:4px; }

/* =====================
   ANIMATIONS
===================== */
@keyframes pulse-blue {
 0%,100% { box-shadow: 0 0 5px rgba(28,60,255,0.4); transform: scale(1); }
 50% { box-shadow: 0 0 20px rgba(28,60,255,0.7); transform: scale(1.02); }
}
@keyframes pulse-orange {
 0%,100% { box-shadow: 0 0 5px rgba(255,165,0,0.4); transform: scale(1); }
 50% { box-shadow: 0 0 20px rgba(255,165,0,0.7); transform: scale(1.02); }
}

@media (max-width:900px){
  .left { flex:0 0 30%; }
  .calendar-cell { min-height:90px; }
}
</style>
</head>
<body>

<div class="left">
    <h2>État des Ponts</h2>
    <div id="ponts-table">Chargement…</div>
</div>

<div class="right">
    <div id="calendar-header">
        <span class="nav-btn" id="prev-btn">‹</span>
        <span id="calendar-title">Chargement…</span>
        <span class="nav-btn" id="next-btn">›</span>
        <span class="view-btn" id="view-3w">3 semaines</span>
        <span class="view-btn" id="view-4w">4 semaines</span>
        <span class="nav-btn" id="today-btn" style="font-size:18px;">Aujourd’hui</span>
    </div>
    <div id="calendar-grid"></div>
</div>

<script>
/* ============================================================
   TON CODE D'ORIGINE (calendrier + ponts) - j'intègre la gestion
   des bandes multi-jours continues et corrige les problèmes.
============================================================ */

/* =====================
   CONFIG CALENDAR
===================== */
const API_KEY = "AIzaSyDkQkqPoOGf8umYg2dbeTU0THfLlJnCjXo";
const CAL_RECEPTION = "receptionroulier@gmail.com";
const CAL_NAVIRE = "smr.programme@gmail.com";

let viewDays = 21; // par défaut 3 semaines
let offsetWeeks = 0;

const CAL_HASH_KEY = "calendarHash";
const CAL_CACHE_KEY = "calendarCache";
const CAL_REFRESH_INTERVAL = 60000; // 1 min

/* PONTS (inchangés) */
const CACHE_KEY_DATA="pontsData";
const CACHE_KEY_HASH="pontsHash";
const CACHE_KEY_TIME="pontsCacheTime";
const CACHE_EXPIRATION=60000;
const REFRESH_INTERVAL=10000;

const PROXIES=[
    "https://api.allorigins.win/get?url=",
    "https://cors-anywhere.herokuapp.com/",
    "https://thingproxy.freeboard.io/fetch/"
];

/* =====================
   UTIL DATES (local date strings safely)
   - Important: produce YYYY-MM-DD in local timezone
===================== */
function getStartMonday(date){
    const d = new Date(date);
    const day = d.getDay();
    const diff = (day === 0 ? -6 : 1) - day;
    d.setDate(d.getDate() + diff);
    return d;
}
function addDays(date,n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function formatDate(d){
    return d.getFullYear().toString().padStart(4,'0') + '-' +
        (d.getMonth()+1).toString().padStart(2,'0') + '-' +
        d.getDate().toString().padStart(2,'0');
}
function formatMonthRange(start,end){
    const m=["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
    const m1=m[start.getMonth()], m2=m[end.getMonth()];
    const y1=start.getFullYear(), y2=end.getFullYear();
    return (m1===m2 && y1===y2)?`${m1} ${y1}`:`${m1} — ${m2} ${y2}`;
}
function dayName(d){ return ["Dim","Lun","Mar","Mer","Jeu","Ven","Sam"][d.getDay()]; }

/* =====================
   HASH UTIL
===================== */
async function hashObject(obj){
    const txt = JSON.stringify(obj);
    const data = new TextEncoder().encode(txt);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,"0")).join("");
}

/* =====================
   FETCH CALENDAR WITH HASH
===================== */
async function fetchCalendarWithHash(start, end){
    const timeMin = start.toISOString();
    const timeMax = addDays(end,1).toISOString();

    const urlRec = `https://www.googleapis.com/calendar/v3/calendars/${CAL_RECEPTION}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;
    const urlNav = `https://www.googleapis.com/calendar/v3/calendars/${CAL_NAVIRE}/events?key=${API_KEY}&timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime`;

    const [recRaw, navRaw] = await Promise.all([
        fetch(urlRec).then(r=>r.json()).catch(()=>({items:[]})),
        fetch(urlNav).then(r=>r.json()).catch(()=>({items:[]})),
    ]);

    const events = { reception: recRaw.items || [], navire: navRaw.items || [] };

    const newHash = await hashObject(events);
    const oldHash = localStorage.getItem(CAL_HASH_KEY);

    if(newHash === oldHash && localStorage.getItem(CAL_CACHE_KEY)){
        try { return JSON.parse(localStorage.getItem(CAL_CACHE_KEY)); } catch {}
    }

    localStorage.setItem(CAL_HASH_KEY,newHash);
    localStorage.setItem(CAL_CACHE_KEY,JSON.stringify(events));
    return events;
}

/* ============================================================
   NORMALISATION GOOGLE EVENTS (start/end -> YYYY-MM-DD local)
   - treat all-day (start.date / end.date exclusive) correctly
   - treat dateTime using local date components (no UTC shift)
============================================================ */
function localYMDFromDateTime(dtString){
    const d = new Date(dtString);
    // get local components
    const y = d.getFullYear();
    const m = (d.getMonth()+1).toString().padStart(2,'0');
    const day = d.getDate().toString().padStart(2,'0');
    return `${y}-${m}-${day}`;
}
function getLocalStartDate(ev){
    if(ev.start?.date) return ev.start.date; // all-day, already YMD
    if(ev.start?.dateTime) return localYMDFromDateTime(ev.start.dateTime);
    return null;
}
function getLocalEndDateInclusive(ev){
    // return inclusive last day (YMD)
    if(ev.end?.date){
        // end.date is exclusive for all-day events => subtract 1 day
        const d = new Date(ev.end.date);
        d.setDate(d.getDate() - 1);
        return formatDate(d);
    }
    if(ev.end?.dateTime){
        // If end time is exactly 00:00:00, it's probably exclusive to next day -> subtract 1ms to include previous day
        const d = new Date(ev.end.dateTime);
        if(d.getHours()===0 && d.getMinutes()===0 && d.getSeconds()===0 && d.getMilliseconds()===0){
            // subtract 1 millisecond to fall into previous day
            const prev = new Date(d.getTime()-1);
            return formatDate(prev);
        }
        return localYMDFromDateTime(ev.end.dateTime);
    }
    return null;
}

/* ============================================================
   GRID CREATION
   - createGrid returns array of date strings for view
============================================================ */
function createGrid(start, viewDays){
    const grid = document.getElementById('calendar-grid');
    const rows = (viewDays===21)?3:4;
    grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    grid.style.gridTemplateColumns = `repeat(7, 1fr)`;
    grid.innerHTML = '';
    const dates = [];
    for(let i=0;i<viewDays;i++){
        const d = addDays(start,i);
        const cell = document.createElement('div');
        cell.className = 'calendar-cell';
        cell.dataset.date = formatDate(d);
        cell.dataset.index = i;
        cell.innerHTML = `<div class="date-label">${dayName(d)} ${d.getDate()}</div>`;
        grid.appendChild(cell);
        dates.push(formatDate(d));
    }
    return dates;
}

/* ============================================================
   LAYOUT MULTI-JOUR CONTINU (bandes placées ABSOLUTE sur #calendar-grid)
   - compute day indexes for each event
   - allocate level (no overlap)
   - create one .multi-band per multi-day event with left/width spanning across cells
   - place bands below single events by z-index
============================================================ */
function allocateLevel(occupied, dayIndexes){
    let level = 0;
    while(true){
        let ok = true;
        for(const di of dayIndexes){
            const row = occupied[di] || [];
            if(row[level]) { ok = false; break; }
        }
        if(ok){
            for(const di of dayIndexes){
                occupied[di] = occupied[di] || [];
                occupied[di][level] = true;
            }
            return level;
        }
        level++;
    }
}

function clearEventLayers(){
    // remove any existing multi-band elements inside calendar-grid
    const grid = document.getElementById('calendar-grid');
    grid.querySelectorAll('.multi-band').forEach(n=>n.remove());
    // also remove previously appended single-day .event nodes (we recreate fresh)
    document.querySelectorAll('.calendar-cell .event').forEach(n=>n.remove());
}

function renderBandsAndEvents(eventsObj, start, viewDays){
    const grid = document.getElementById('calendar-grid');
    const cells = Array.from(grid.querySelectorAll('.calendar-cell'));
    const dateToIndex = {};
    cells.forEach(c => dateToIndex[c.dataset.date] = parseInt(c.dataset.index,10));

    // Collect multi-day events (span >=2 days in view)
    const multi = [];
    const single = []; // single-day events (span ===1) to render as .event in cell

    ['reception','navire'].forEach(type=>{
        (eventsObj[type] || []).forEach(ev=>{
            const s = getLocalStartDate(ev);
            const e = getLocalEndDateInclusive(ev);
            if(!s || !e) return;
            const sDate = new Date(s + 'T00:00:00');
            const eDate = new Date(e + 'T00:00:00');
            const span = Math.round((eDate - sDate)/86400000) + 1;
            // compute day indexes inside view:
            const dayIndexes = [];
            for(let d = new Date(sDate); d <= eDate; d = addDays(d,1)){
                const key = formatDate(d);
                if(key in dateToIndex) dayIndexes.push(dateToIndex[key]);
            }
            if(dayIndexes.length === 0) {
                // out of view
                return;
            }
            const item = {
                type,
                original: ev,
                summary: ev.summary || '(Sans titre)',
                startYMD: s,
                endYMD: e,
                dayIndexes
            };
            if(span >= 2) multi.push(item); else single.push(item);
        });
    });

    // allocate levels across day indexes for multi events
    const occupied = {}; // occupied[dayIndex] = [bool,...]
    // determine maximum level to compute needed vertical space
    let maxLevel = 0;
    multi.forEach(ev=>{
        const level = allocateLevel(occupied, ev.dayIndexes);
        ev.level = level;
        if(level > maxLevel) maxLevel = level;
    });

    // create bands as single absolute elements spanning from first cell left to last cell right
    multi.forEach(ev=>{
        const firstIndex = ev.dayIndexes[0];
        const lastIndex = ev.dayIndexes[ev.dayIndexes.length-1];
        const firstCell = grid.querySelector(`.calendar-cell[data-index="${firstIndex}"]`);
        const lastCell = grid.querySelector(`.calendar-cell[data-index="${lastIndex}"]`);
        if(!firstCell || !lastCell) return;

        // compute positions relative to grid
        // use offsetLeft/offsetWidth because grid is positioned and not transformed
        const gridRect = grid.getBoundingClientRect();
        const firstRect = firstCell.getBoundingClientRect();
        const lastRect = lastCell.getBoundingClientRect();
        const left = firstRect.left - gridRect.left + grid.scrollLeft;
        const right = (lastRect.left - gridRect.left + lastRect.width) + grid.scrollLeft;
        const width = right - left;

        const band = document.createElement('div');
        band.className = `multi-band ${ev.type}`;
        // position inside grid
        band.style.left = (left + 6) + 'px'; // small padding to match cell padding
        band.style.width = (Math.max(20, width - 12)) + 'px'; // keep minimal width
        // vertical placement: top margin below date label area (approx 26px) plus level spacing
        const topBase = 26; // pixels from top of cell area to first band
        const levelSpacing = 24; // pixels per level
        band.style.top = (topBase + ev.level * levelSpacing) + 'px';

        // left content: start time + title (only show in leftmost visible portion)
        const leftDiv = document.createElement('div');
        leftDiv.className = 'left';
        // compute start time if dateTime present
        let startTimeStr = '';
        if(ev.original && ev.original.start && ev.original.start.dateTime){
            const d = new Date(ev.original.start.dateTime);
            startTimeStr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0') + ' ';
        }
        leftDiv.textContent = (startTimeStr + ev.summary).slice(0,200); // guard long text
        leftDiv.style.flex = '1 1 auto';
        leftDiv.style.overflow = 'hidden';
        leftDiv.style.textOverflow = 'ellipsis';
        leftDiv.style.paddingRight = '8px';
        leftDiv.title = ev.summary;

        // right content: end time (only show in last visible day)
        const rightDiv = document.createElement('div');
        rightDiv.className = 'right';
        rightDiv.style.flex = '0 0 auto';
        let endTimeStr = '';
        if(ev.original && ev.original.end && ev.original.end.dateTime){
            const ed = new Date(ev.original.end.dateTime);
            endTimeStr = '>' + ed.getHours().toString().padStart(2,'0') + ':' + ed.getMinutes().toString().padStart(2,'0');
        }
        rightDiv.textContent = endTimeStr;
        rightDiv.style.marginLeft = '6px';

        band.appendChild(leftDiv);
        band.appendChild(rightDiv);

        // attach attributes for debug
        band.dataset.evId = ev.original.id || '';
        band.title = ev.summary + '\n' + ev.startYMD + ' → ' + ev.endYMD;

        // insert band into grid (so it's under .event which is z-index 4)
        grid.appendChild(band);
    });

    // render single-day events into cells (these will be above bands due to z-index)
    single.forEach(ev=>{
        const dateKey = ev.startYMD;
        const cell = document.querySelector(`.calendar-cell[data-date="${dateKey}"]`);
        if(!cell) return;
        const div = document.createElement('div');
        div.className = 'event ' + ev.type;
        // show time if available
        let timeStr = '';
        if(ev.original.start && ev.original.start.dateTime){
            const d = new Date(ev.original.start.dateTime);
            timeStr = d.getHours().toString().padStart(2,'0') + ':' + d.getMinutes().toString().padStart(2,'0') + ' ';
        }
        div.innerHTML = `${timeStr}${ev.summary || '(Sans titre)'}`;
        cell.appendChild(div);
    });

    // ensure enough vertical space: adjust min-height of grid rows if many levels
    const totalRequiredHeight = 26 + (maxLevel + 1) * 24 + 10; // base + levels*spacing + cushion
    // set each cell min-height accordingly
    cells.forEach(c => {
        c.style.minHeight = Math.max(70, totalRequiredHeight) + 'px';
    });
}

/* ============================================================
   MAIN LOAD FUNCTION
============================================================ */
async function loadCalendar(){
    const today = new Date();
    const mondayCurrent = getStartMonday(today);
    const start = new Date(mondayCurrent);
    start.setDate(start.getDate() - 7 + offsetWeeks*7);
    const end = addDays(start, viewDays - 1);
    document.getElementById('calendar-title').textContent = formatMonthRange(start, end);

    // create grid
    createGrid(start, viewDays);

    // clear any previous bands/events
    clearEventLayers();

    try {
        const events = await fetchCalendarWithHash(start, end);
        // render continuous bands and single-day events
        renderBandsAndEvents(events, start, viewDays);
    } catch(err){
        console.error('Erreur loadCalendar:', err);
    }
}

/* =====================
   NAVIGATION
===================== */
document.getElementById("prev-btn").onclick = ()=>{ offsetWeeks -= 1; loadCalendar(); };
document.getElementById("next-btn").onclick = ()=>{ offsetWeeks += 1; loadCalendar(); };
document.getElementById("today-btn").onclick = ()=>{ offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-3w").onclick = ()=>{ viewDays = 21; offsetWeeks = 0; loadCalendar(); };
document.getElementById("view-4w").onclick = ()=>{ viewDays = 28; offsetWeeks = 0; loadCalendar(); };

loadCalendar();
setInterval(loadCalendar, CAL_REFRESH_INTERVAL);

/* ============================================================
   PONTS HAROPA (inchangée : ta logique conservée)
============================================================ */
async function sha256(str){
    const data=new TextEncoder().encode(str);
    const digest=await crypto.subtle.digest("SHA-256",data);
    return Array.from(new Uint8Array(digest)).map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function fetchWithRandomProxy(url) {
    const shuffled = [...PROXIES].sort(() => Math.random() - 0.5);
    for (const proxy of shuffled) {
        try {
            const fullUrl = proxy + encodeURIComponent(url);
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);
            const res = await fetch(fullUrl, { signal: controller.signal });
            clearTimeout(timeout);
            if (!res.ok) throw new Error(`Proxy failed: ${res.status}`);
            let txt = await res.text();
            try { const parsed = JSON.parse(txt); if (parsed.contents) return parsed.contents; } catch {}
            return txt;
        }
        catch(err){
            console.warn(`Proxy ${proxy} échoué : ${err.message}`);
        }
    }
    throw new Error("Tous les proxys ont échoué");
}
async function checkAndUpdate(){
    const now = Date.now();
    const last = localStorage.getItem(CACHE_KEY_TIME);
    if (last && now-last < CACHE_EXPIRATION){
        const cached = localStorage.getItem(CACHE_KEY_DATA);
        if (cached){ renderPonts(JSON.parse(cached)); return; }
    }
    await fetchWithHashControl();
}
async function fetchWithHashControl(){
    try{
        const rawContent = await fetchWithRandomProxy("https://www.havre-port.com/map/getPonts");
        const newHash = await sha256(rawContent);
        const oldHash = localStorage.getItem(CACHE_KEY_HASH);
        if (newHash === oldHash && localStorage.getItem(CACHE_KEY_DATA)){
            renderPonts(JSON.parse(localStorage.getItem(CACHE_KEY_DATA)));
            return;
        }
        const ponts = Object.values(JSON.parse(rawContent).data);
        const unique = Array.from(new Map(ponts.map(p=>[p.nom,p])).values());
        const ordered = unique.sort((a,b)=>{
            const score=p=>{
                const s=p.statutText.toLowerCase();
                if(s.includes("fermeture")) return 1;
                if(s.includes("fermé")) return 2;
                if(s.includes("manoeuvre")) return 3;
                if(s.includes("ouvert")) return 4;
                return 5;
            };
            return score(a)-score(b);
        });
        localStorage.setItem(CACHE_KEY_DATA,JSON.stringify(ordered));
        localStorage.setItem(CACHE_KEY_HASH,newHash);
        localStorage.setItem(CACHE_KEY_TIME,Date.now());
        renderPonts(ordered);
    }
    catch(err){
        console.error("Erreur récupération ponts:",err);
        document.getElementById("ponts-table").textContent="Impossible de récupérer les ponts.";
    }
}
function renderPonts(list){
    const container=document.getElementById("ponts-table");
    container.innerHTML=list.map(p=>{
        const s=p.statutText.toLowerCase();
        const cls =
            s.includes("fermeture") ? "fermeture" :
            s.includes("fermé")      ? "ferme" :
            s.includes("manoeuvre")  ? "manoeuvre" :
            s.includes("ouvert")     ? "ouvert" : "ferme";
        const info = p.forceText || `MàJ : ${p.date}`;
        return `<div class="pont-card ${cls}">
            <div class="pont-nom"><span class="pastille"></span>${p.nom}</div>
            <div class="pont-etat">${p.statutText}</div>
            <div class="pont-infos">${info}</div></div>`;
    }).join("");
}
checkAndUpdate();
setInterval(checkAndUpdate,REFRESH_INTERVAL);
</script>
</body>
</html>
